{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Hyv\u00e4 Admin Hyva_Admin is a Magento 2 module that offers a new way to create admin grids. Existing grids and forms are not affected by installing the module; they remain unchanged. Hyva_Admin exists to improve the developer experience while creating new grids. In future, Hyva_Admin will support creating forms, too. About Hyva_Admin Hyva_Admin is a Magento 2 module that offers a new way to create admin grids. Existing grids and forms are not affected by installing the module; they remain unchanged. Hyva_Admin exists to improve the developer experience while creating new grids. Documentation Pull Requests Please note that the documentation is maintained in a separate internal system. As much as help writing documentation is appreciated, please do not include documentation updates in pull requests, as those updates would be overwritten by the next documentation export. Please contact vinai@netzarbeiter.com to discuss alternative ways to contribute documentation changes.","title":"Welcome"},{"location":"index.html#hyva-admin","text":"Hyva_Admin is a Magento 2 module that offers a new way to create admin grids. Existing grids and forms are not affected by installing the module; they remain unchanged. Hyva_Admin exists to improve the developer experience while creating new grids. In future, Hyva_Admin will support creating forms, too.","title":"Hyv\u00e4 Admin"},{"location":"index.html#about-hyva_admin","text":"Hyva_Admin is a Magento 2 module that offers a new way to create admin grids. Existing grids and forms are not affected by installing the module; they remain unchanged. Hyva_Admin exists to improve the developer experience while creating new grids.","title":"About Hyva_Admin"},{"location":"index.html#documentation-pull-requests","text":"Please note that the documentation is maintained in a separate internal system. As much as help writing documentation is appreciated, please do not include documentation updates in pull requests, as those updates would be overwritten by the next documentation export. Please contact vinai@netzarbeiter.com to discuss alternative ways to contribute documentation changes.","title":"Documentation Pull Requests"},{"location":"api-reference/event-reference/index.html","text":"Event Reference Hyva_Admin dispatches some events to allow customization. The events are: 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName) 'hyva_grid_source_prefetch' 'hyva_grid_column_definition_build_after_' . $this->getGridNameEventSuffix($gridName) The event name suffix is based on the grid name. Because the Magento events.xml schema only allows alphanumeric characters in event names, any non-alphanumeric characters are transformed into underscores, e.g hyva_grid_source_prefetch_product-grid (invalid) becomes hyva_grid_source_prefetch_product_grid (valid). Please refer to the nested pages for detailed information.","title":"Overview"},{"location":"api-reference/event-reference/index.html#event-reference","text":"Hyva_Admin dispatches some events to allow customization. The events are: 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName) 'hyva_grid_source_prefetch' 'hyva_grid_column_definition_build_after_' . $this->getGridNameEventSuffix($gridName) The event name suffix is based on the grid name. Because the Magento events.xml schema only allows alphanumeric characters in event names, any non-alphanumeric characters are transformed into underscores, e.g hyva_grid_source_prefetch_product-grid (invalid) becomes hyva_grid_source_prefetch_product_grid (valid). Please refer to the nested pages for detailed information.","title":"Event Reference"},{"location":"api-reference/event-reference/grid-column-definition-build-after-event.html","text":"Grid Column Definition Build After Event Usually columns are customized by configuring them in grid XML. However, there might be situations where column definitions need to be changed depending on some conditional logic. The hyva_grid_column_definition_build_after event was introduced for this purpose. After the column definition have been built, based on the grid record type and the grid configuration, this event allows for further programatic customization. The dispatched event is 'hyva_grid_column_definition_build_after_' . $this->getGridNameEventSuffix($gridName) The grid event name suffix is the grid name in lower case with underscores instead of non-alphanumeric characters. For example a grid named product-grid will dispatch events named hyva_grid_column_definition_build_after_product_grid . Event Arguments The event arguments are [ 'grid_name' => $gridName, 'data_container' => $container ] The grid name is passed along with the event for informational purposes, changing it has no effect. The data container is an instance of HyvaAdminModelGridSourceTypeRepositorySourceTypeHyvaGridEventContainer . The container instance contains an associative array with all grid columns definition instances; the array keys being the column IDs. Observers To update a column definition follow this pattern: public function execute(Observer $observer) { /** @varHyvaAdminModelGridSourceTypeRepositorySourceTypeHyvaGridEventContainer $container */ /** @varHyvaAdminViewModelHyvaGridColumnDefinitionInterface[] $columnsMap */ $container = $observer->getData('data_container'); $columnsMap = $container->getContainerData(); // map of keys to column definitions $columnsMap['example'] = $columnsMap['example']->merge(['initiallyHidden' => 'true']); $container->replaceContainerData($columnsMap); } Note: the ColumnDefinition::merge() method does not change the existing instance, instead, it returns a new instance with the merged properties applied. The argument with the properties to merge can be an associative array, or it can be another ColumnDefinitionInterface instance.","title":"Grid Column Definition Build After Event"},{"location":"api-reference/event-reference/grid-column-definition-build-after-event.html#grid-column-definition-build-after-event","text":"Usually columns are customized by configuring them in grid XML. However, there might be situations where column definitions need to be changed depending on some conditional logic. The hyva_grid_column_definition_build_after event was introduced for this purpose. After the column definition have been built, based on the grid record type and the grid configuration, this event allows for further programatic customization. The dispatched event is 'hyva_grid_column_definition_build_after_' . $this->getGridNameEventSuffix($gridName) The grid event name suffix is the grid name in lower case with underscores instead of non-alphanumeric characters. For example a grid named product-grid will dispatch events named hyva_grid_column_definition_build_after_product_grid .","title":"Grid Column Definition Build After Event"},{"location":"api-reference/event-reference/grid-column-definition-build-after-event.html#event-arguments","text":"The event arguments are [ 'grid_name' => $gridName, 'data_container' => $container ] The grid name is passed along with the event for informational purposes, changing it has no effect. The data container is an instance of HyvaAdminModelGridSourceTypeRepositorySourceTypeHyvaGridEventContainer . The container instance contains an associative array with all grid columns definition instances; the array keys being the column IDs.","title":"Event Arguments"},{"location":"api-reference/event-reference/grid-column-definition-build-after-event.html#observers","text":"To update a column definition follow this pattern: public function execute(Observer $observer) { /** @varHyvaAdminModelGridSourceTypeRepositorySourceTypeHyvaGridEventContainer $container */ /** @varHyvaAdminViewModelHyvaGridColumnDefinitionInterface[] $columnsMap */ $container = $observer->getData('data_container'); $columnsMap = $container->getContainerData(); // map of keys to column definitions $columnsMap['example'] = $columnsMap['example']->merge(['initiallyHidden' => 'true']); $container->replaceContainerData($columnsMap); } Note: the ColumnDefinition::merge() method does not change the existing instance, instead, it returns a new instance with the merged properties applied. The argument with the properties to merge can be an associative array, or it can be another ColumnDefinitionInterface instance.","title":"Observers"},{"location":"api-reference/event-reference/grid-query-before-event.html","text":"Grid Query Before Event This query is dispatched for grids using an grid source type. First, a MagentoFrameworkDBSelect instance is created and the query configuration from the grid XML configuration is applied. (Note: MagentoFrameworkDBSelect is just a small wrapper for Zend_Db_Select , the API is the same). Then then filters, sorting and pagination are applied. Finally, right before the SQL query is executed, the 'hyva_grid_query_before_' . $this->getGridNameEventSuffix($this->gridName); event is dispatched. This allows to modify or even completely replace the select that is used to load the grid data. Event Arguments The event arguments are: [ 'select_container' => $container, 'grid_name' => $this->gridName, ] The container is an instance of HyvaAdminModelGridSourceTypeQueryGridSourceTypeDbSelectEventContainer . Observers Observers can modify or replace the select instance as follows: public function execute(Observer $observer) { /** @var DbSelectEventContainer $container */ $container = $observer->getData('select_container'); $select = $container->getSelect(); $updatedSelect = $this->modifyQuery($select); $container->replaceSelect($updatedSelect); }","title":"Grid Query Before Event"},{"location":"api-reference/event-reference/grid-query-before-event.html#grid-query-before-event","text":"This query is dispatched for grids using an grid source type. First, a MagentoFrameworkDBSelect instance is created and the query configuration from the grid XML configuration is applied. (Note: MagentoFrameworkDBSelect is just a small wrapper for Zend_Db_Select , the API is the same). Then then filters, sorting and pagination are applied. Finally, right before the SQL query is executed, the 'hyva_grid_query_before_' . $this->getGridNameEventSuffix($this->gridName); event is dispatched. This allows to modify or even completely replace the select that is used to load the grid data.","title":"Grid Query Before Event"},{"location":"api-reference/event-reference/grid-query-before-event.html#event-arguments","text":"The event arguments are: [ 'select_container' => $container, 'grid_name' => $this->gridName, ] The container is an instance of HyvaAdminModelGridSourceTypeQueryGridSourceTypeDbSelectEventContainer .","title":"Event Arguments"},{"location":"api-reference/event-reference/grid-query-before-event.html#observers","text":"Observers can modify or replace the select instance as follows: public function execute(Observer $observer) { /** @var DbSelectEventContainer $container */ $container = $observer->getData('select_container'); $select = $container->getSelect(); $updatedSelect = $this->modifyQuery($select); $container->replaceSelect($updatedSelect); }","title":"Observers"},{"location":"api-reference/event-reference/grid-source-prefetch-events.html","text":"Grid Source Prefetch Events Before the grid data is loaded from the grid source object, two events are dispatched. 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName) 'hyva_grid_source_prefetch' The grid name event suffix is basically the grid name in lower case, with underscores instead of non-alphanumeric characters. For example, a grid named product-grid would dispatch the event hyva_grid_source_prefetch_product_grid . Both events are intended to be used to customize the search criteria instance that will be passed to the grid source. Event Arguments The event arguments are [ 'search_criteria_container' => $container, 'grid_name' => $gridName, 'record_type' => $recordType ] The container is an instance of HyvaAdminModelGridSourceTypeRepositorySourceTypeSearchCriteriaEventContainer . The record type argument is the type for the grid records. It will either be a PHP class or interface, or the string array , or a database table name, depending on the grid configuration. The grid name and the record type are passed along with the event for informational purposes, they can not be changed by observers. Observers In an event observer, the search criteria can be updated as shown in this example: public function execute(Observer $observer) { /** @var SearchCriteriaEventContainer $searchCriteriaContainer */ $searchCriteriaContainer = $event->getData('search_criteria_container'); $type = $event->getData('record_type'); $updatedSearchCriteria = $this->changeCriteria($type, $searchCriteriaContainer->getSearchCriteria()); $searchCriteriaContainer->replaceSearchCriteria($updatedSearchCriteria); }","title":"Grid Source Prefetch Events"},{"location":"api-reference/event-reference/grid-source-prefetch-events.html#grid-source-prefetch-events","text":"Before the grid data is loaded from the grid source object, two events are dispatched. 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName) 'hyva_grid_source_prefetch' The grid name event suffix is basically the grid name in lower case, with underscores instead of non-alphanumeric characters. For example, a grid named product-grid would dispatch the event hyva_grid_source_prefetch_product_grid . Both events are intended to be used to customize the search criteria instance that will be passed to the grid source.","title":"Grid Source Prefetch Events"},{"location":"api-reference/event-reference/grid-source-prefetch-events.html#event-arguments","text":"The event arguments are [ 'search_criteria_container' => $container, 'grid_name' => $gridName, 'record_type' => $recordType ] The container is an instance of HyvaAdminModelGridSourceTypeRepositorySourceTypeSearchCriteriaEventContainer . The record type argument is the type for the grid records. It will either be a PHP class or interface, or the string array , or a database table name, depending on the grid configuration. The grid name and the record type are passed along with the event for informational purposes, they can not be changed by observers.","title":"Event Arguments"},{"location":"api-reference/event-reference/grid-source-prefetch-events.html#observers","text":"In an event observer, the search criteria can be updated as shown in this example: public function execute(Observer $observer) { /** @var SearchCriteriaEventContainer $searchCriteriaContainer */ $searchCriteriaContainer = $event->getData('search_criteria_container'); $type = $event->getData('record_type'); $updatedSearchCriteria = $this->changeCriteria($type, $searchCriteriaContainer->getSearchCriteria()); $searchCriteriaContainer->replaceSearchCriteria($updatedSearchCriteria); }","title":"Observers"},{"location":"api-reference/grid-xml-reference/index.html","text":"Grid XML Reference The nested documents describe the XML configuration for Hyva Admin grids. When the configurations for a grid is loaded, it is merged from all modules, just like any other Magento 2 XML configuration file. This allows customizing grids that are declared in other modules. The API reference documents are sorted in alphabetical order. If you want to read them all that\u2019s fine, but if you only want to dip your toes into Hyva_Admin grids, I suggest you start with the grid > source configuration, followed by the grid > columns > includes config. Everything else can then be loaded into your brain when it is needed. The grid XML schema may also be of interest - it can be found in the Hyv\u00e4_Admin module at etc/hyva-grid.xsd .","title":"Overview"},{"location":"api-reference/grid-xml-reference/index.html#grid-xml-reference","text":"The nested documents describe the XML configuration for Hyva Admin grids. When the configurations for a grid is loaded, it is merged from all modules, just like any other Magento 2 XML configuration file. This allows customizing grids that are declared in other modules. The API reference documents are sorted in alphabetical order. If you want to read them all that\u2019s fine, but if you only want to dip your toes into Hyva_Admin grids, I suggest you start with the grid > source configuration, followed by the grid > columns > includes config. Everything else can then be loaded into your brain when it is needed. The grid XML schema may also be of interest - it can be found in the Hyv\u00e4_Admin module at etc/hyva-grid.xsd .","title":"Grid XML Reference"},{"location":"api-reference/grid-xml-reference/actions/index.html","text":"grid > actions By default a grid as no actions. When actions are configured, they are rendered as the right-most column. Currently each action is rendered as a link. The actions element has a single optional attribute idColumn . It is used to specify the column that contains the value to pass to the link destination as a query parameter. < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > If no idColumn is configured, the first column in the grid is used to supply the record identifiers.","title":"Overview"},{"location":"api-reference/grid-xml-reference/actions/index.html#grid-actions","text":"By default a grid as no actions. When actions are configured, they are rendered as the right-most column. Currently each action is rendered as a link. The actions element has a single optional attribute idColumn . It is used to specify the column that contains the value to pass to the link destination as a query parameter. < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > If no idColumn is configured, the first column in the grid is used to supply the record identifiers.","title":"grid &gt; actions"},{"location":"api-reference/grid-xml-reference/actions/action/index.html","text":"grid > actions > action Each action is rendered as a link. An action element has three required attributes and one optional one: id The id attribute is used so it is possible to reference actions during XML merging or as a row action. It is not used in rendering. label The label is used to render the link for that action in the action column. url The url is used to specify the action target. The usual Magento route specification is used, i.e. * is used to reference the current module, action path or action. */*/* refers to the current action that displays the grid. */*/foo refers to the current route, current action path, foo action class. idParam (optional) The idParam attribute is used to configure the query parameter name to pass the id column value to the target action. If no idParam is present, the idColumn name is used. If no idColumn is set on the actions element, the idColumn defaults to the idParam , or - if that doesn\u2019t match a column - the first column in the grid. Examples: < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Render two actions Edit and Delete . Both will pass the value of the column id with the query param id to the destination controller. < actions > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> </ actions > Render one action Edit . Pass the value of the first column to the destination controller using the query param named after the first column key. < actions > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" idParam = \"sku\" /> </ actions > Render one action Delete . If there is a column sku in the grid, pass the value of that column to the destination controller with the query param sku . If there is no column sku , pass the value of the first column to the destination controller using the query param sku . < actions idColumn = \"sku\" > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Render one action Delete . Pass the value of the column sku to the destination controller using the query parameter sku . Note: you will have to create the target actions yourself - they are not created automatically by Hyva_Admin ;)","title":"Overview"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#grid-actions-action","text":"Each action is rendered as a link. An action element has three required attributes and one optional one:","title":"grid &gt; actions &gt; action"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#id","text":"The id attribute is used so it is possible to reference actions during XML merging or as a row action. It is not used in rendering.","title":"id"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#label","text":"The label is used to render the link for that action in the action column.","title":"label"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#url","text":"The url is used to specify the action target. The usual Magento route specification is used, i.e. * is used to reference the current module, action path or action. */*/* refers to the current action that displays the grid. */*/foo refers to the current route, current action path, foo action class.","title":"url"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#idparam-optional","text":"The idParam attribute is used to configure the query parameter name to pass the id column value to the target action. If no idParam is present, the idColumn name is used. If no idColumn is set on the actions element, the idColumn defaults to the idParam , or - if that doesn\u2019t match a column - the first column in the grid.","title":"idParam (optional)"},{"location":"api-reference/grid-xml-reference/actions/action/index.html#examples","text":"< actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Render two actions Edit and Delete . Both will pass the value of the column id with the query param id to the destination controller. < actions > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> </ actions > Render one action Edit . Pass the value of the first column to the destination controller using the query param named after the first column key. < actions > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" idParam = \"sku\" /> </ actions > Render one action Delete . If there is a column sku in the grid, pass the value of that column to the destination controller with the query param sku . If there is no column sku , pass the value of the first column to the destination controller using the query param sku . < actions idColumn = \"sku\" > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Render one action Delete . Pass the value of the column sku to the destination controller using the query parameter sku . Note: you will have to create the target actions yourself - they are not created automatically by Hyva_Admin ;)","title":"Examples:"},{"location":"api-reference/grid-xml-reference/actions/action/event.html","text":"grid > actions > action > event Status: experimental The API for the action event node might be removed or changed in future. Specifying event triggers on actions allows creating complex ui customizations. Only the event trigger can be specified in the grid XML: < actions > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" > < event on = \"click\" /> </ action > </ actions > Event Name The event name is built based on the grid name, the action id and the event trigger: private function getEventName(): string { $gridNameInEvent = $this->eventify($this->gridName); return sprintf('hyva-grid-%s-action-%s-%s', $gridNameInEvent, $this->eventify($this->targetId), $this->on); } For example, given a grid named products-query-grid, and an action with the id delete, the JavaScript event that is dispatched is hyva-grid-products-query-grid-action-delete-click Event Subscribers Event subscribers can be declared in .phtml template files that are added to the grid page via layout XML. Example: < script > window . addEventListener ( 'hyva-grid-products-grid-action-delete-click' , e => { if ( ! confirm ( '<?= __(' Are you sure ? ') ?>' )) { e . detail . origEvent . preventDefault (); } }); < /script> Event Arguments The event arguments can be retrieved from the events.detail property in subscribers. event.detail.origEvent This is the original event that was triggered by the user interaction. probably this is mainly useful to abort user actions with event.detail.origEvent.preventDefault() . event.detail.row This property is a reference to the clicked grid table row. It might be useful to retrieve the rendered cell values in a kind of hacky way. event.detail.viewModel This is the Alpine.js view model of the grid. event.detail.action This is the grid action id. In the examples on this page it is the string delete . event.detail.params This is the map of parameters that would be passed to the URL. It depends on the action configuration. The following example will add the params {foo => idValue} : < actions idColumn = \"id\" > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" idParam = \"foo\" > < event on = \"click\" /> </ action > </ actions >","title":"grid > actions > action > event"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#grid-actions-action-event","text":"Status: experimental The API for the action event node might be removed or changed in future. Specifying event triggers on actions allows creating complex ui customizations. Only the event trigger can be specified in the grid XML: < actions > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" > < event on = \"click\" /> </ action > </ actions >","title":"grid &gt; actions &gt; action &gt; event"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#event-name","text":"The event name is built based on the grid name, the action id and the event trigger: private function getEventName(): string { $gridNameInEvent = $this->eventify($this->gridName); return sprintf('hyva-grid-%s-action-%s-%s', $gridNameInEvent, $this->eventify($this->targetId), $this->on); } For example, given a grid named products-query-grid, and an action with the id delete, the JavaScript event that is dispatched is hyva-grid-products-query-grid-action-delete-click","title":"Event Name"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#event-subscribers","text":"Event subscribers can be declared in .phtml template files that are added to the grid page via layout XML. Example: < script > window . addEventListener ( 'hyva-grid-products-grid-action-delete-click' , e => { if ( ! confirm ( '<?= __(' Are you sure ? ') ?>' )) { e . detail . origEvent . preventDefault (); } }); < /script>","title":"Event Subscribers"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#event-arguments","text":"The event arguments can be retrieved from the events.detail property in subscribers.","title":"Event Arguments"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#eventdetailorigevent","text":"This is the original event that was triggered by the user interaction. probably this is mainly useful to abort user actions with event.detail.origEvent.preventDefault() .","title":"event.detail.origEvent"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#eventdetailrow","text":"This property is a reference to the clicked grid table row. It might be useful to retrieve the rendered cell values in a kind of hacky way.","title":"event.detail.row"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#eventdetailviewmodel","text":"This is the Alpine.js view model of the grid.","title":"event.detail.viewModel"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#eventdetailaction","text":"This is the grid action id. In the examples on this page it is the string delete .","title":"event.detail.action"},{"location":"api-reference/grid-xml-reference/actions/action/event.html#eventdetailparams","text":"This is the map of parameters that would be passed to the URL. It depends on the action configuration. The following example will add the params {foo => idValue} : < actions idColumn = \"id\" > < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" idParam = \"foo\" > < event on = \"click\" /> </ action > </ actions >","title":"event.detail.params"},{"location":"api-reference/grid-xml-reference/columns/index.html","text":"grid > columns Showing and hiding columns If no columns are configured, the default is to show all available fields. If the default isn\u2019t sufficient, the columns can be configured using the grid/columns/include and grid/columns/exclude child nodes. The behavior what is displayed is quite intuitive, but not super simple to explain in words: No include and no exclude configuration: \u2192 display all columns Only include and no exclude configuration: \u2192 display only the columns under include . No include and only an exclude configuration: \u2192 display all columns except the excluded ones. Both include and exclude configuration: \u2192 display all included columns except the ones that where excluded. The include element can have an option attribute keepAllSourceColumns . If it is present and set to true , then configuring include columns will not automatically hide other available columns. Grid row actions Grid columns can have a rowAction attribute, which refers to the ID value of an action configured in the grid/actions element. < columns rowAction = \"edit\" > .... </ columns > < actions > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> </ actions > The row action is triggered when a row is clicked. Examples: Display all available columns (just as if no <columns/> node where present): < columns > </ columns > Display only the id and sku columns: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> </ include > </ columns > Display all available source columns except the category_gear column: < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > Display the id , sku and name columns only: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"activity\" /> < column name = \"name\" /> </ include > < exclude > < column name = \"activity\" /> </ exclude > </ columns > Display all available columns except the category_gear column: < columns > < include keepAllSourceColumns = \"true\" > < column name = \"id\" /> < column name = \"price\" type = \"price\" /> </ include > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > The id column will be displayed first, and the price column will be displayed second, and the value will be rendered as a price.","title":"Overview"},{"location":"api-reference/grid-xml-reference/columns/index.html#grid-columns","text":"","title":"grid &gt; columns"},{"location":"api-reference/grid-xml-reference/columns/index.html#showing-and-hiding-columns","text":"If no columns are configured, the default is to show all available fields. If the default isn\u2019t sufficient, the columns can be configured using the grid/columns/include and grid/columns/exclude child nodes. The behavior what is displayed is quite intuitive, but not super simple to explain in words: No include and no exclude configuration: \u2192 display all columns Only include and no exclude configuration: \u2192 display only the columns under include . No include and only an exclude configuration: \u2192 display all columns except the excluded ones. Both include and exclude configuration: \u2192 display all included columns except the ones that where excluded. The include element can have an option attribute keepAllSourceColumns . If it is present and set to true , then configuring include columns will not automatically hide other available columns.","title":"Showing and hiding columns"},{"location":"api-reference/grid-xml-reference/columns/index.html#grid-row-actions","text":"Grid columns can have a rowAction attribute, which refers to the ID value of an action configured in the grid/actions element. < columns rowAction = \"edit\" > .... </ columns > < actions > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> </ actions > The row action is triggered when a row is clicked.","title":"Grid row actions"},{"location":"api-reference/grid-xml-reference/columns/index.html#examples","text":"Display all available columns (just as if no <columns/> node where present): < columns > </ columns > Display only the id and sku columns: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> </ include > </ columns > Display all available source columns except the category_gear column: < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > Display the id , sku and name columns only: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"activity\" /> < column name = \"name\" /> </ include > < exclude > < column name = \"activity\" /> </ exclude > </ columns > Display all available columns except the category_gear column: < columns > < include keepAllSourceColumns = \"true\" > < column name = \"id\" /> < column name = \"price\" type = \"price\" /> </ include > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > The id column will be displayed first, and the price column will be displayed second, and the value will be rendered as a price.","title":"Examples:"},{"location":"api-reference/grid-xml-reference/columns/exclude/index.html","text":"grid > columns > exclude Without any exclude columns, all columns will be displayed. Exclude columns can be used to hide columns from a grid. < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns >","title":"Overview"},{"location":"api-reference/grid-xml-reference/columns/exclude/index.html#grid-columns-exclude","text":"Without any exclude columns, all columns will be displayed. Exclude columns can be used to hide columns from a grid. < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns >","title":"grid &gt; columns &gt; exclude"},{"location":"api-reference/grid-xml-reference/columns/exclude/column.html","text":"grid > columns > exclude > column Exclude columns only have a single required attribute name. < exclude > < column name = \"internal_id\" /> </ exclude >","title":"grid > columns > exclude > column"},{"location":"api-reference/grid-xml-reference/columns/exclude/column.html#grid-columns-exclude-column","text":"Exclude columns only have a single required attribute name. < exclude > < column name = \"internal_id\" /> </ exclude >","title":"grid &gt; columns &gt; exclude &gt; column"},{"location":"api-reference/grid-xml-reference/columns/include/index.html","text":"grid > columns > include If present, only the included columns will be rendered. The behavior can be changed by specifying the attribute keepAllSourceColumns=\"true\" . Examples: Display only the id and sku columns: < include > < column name = \"id\" /> < column name = \"sku\" /> </ include > Display all available columns: < include keepAllSourceColumns = \"true\" > < column name = \"id\" /> < column name = \"sku\" /> </ include > Using keepAllSourceColumns=\"true\" is useful for specifying additional properties for individual columns, or for moving only some columns to the left side of the grid.","title":"Overview"},{"location":"api-reference/grid-xml-reference/columns/include/index.html#grid-columns-include","text":"If present, only the included columns will be rendered. The behavior can be changed by specifying the attribute keepAllSourceColumns=\"true\" .","title":"grid &gt; columns &gt; include"},{"location":"api-reference/grid-xml-reference/columns/include/index.html#examples","text":"Display only the id and sku columns: < include > < column name = \"id\" /> < column name = \"sku\" /> </ include > Display all available columns: < include keepAllSourceColumns = \"true\" > < column name = \"id\" /> < column name = \"sku\" /> </ include > Using keepAllSourceColumns=\"true\" is useful for specifying additional properties for individual columns, or for moving only some columns to the left side of the grid.","title":"Examples:"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html","text":"grid > columns > include > column The include column element allows configuring if column should be displayed or not, and if it is displayed, how the column should be rendered. The include column can have a number of attributes, almost all of which are optional: name (required) label type template renderAsUnsecureHtml rendererBlockName sortOrder sortable source initiallyHidden In the following you can find a description of each column attribute. name This is the only required attribute. It specifies the column key that is used to fetch the cell value from the grid source record. < column name = \"sku\" /> label The label is shown as the column title. Without a label attribute the title is determined from the column name. < column name = \"image\" label = \"Main Image\" /> type The type influences how a column value is rendered in a grid cell. It sometimes can be determined automatically, but then again, sometimes Hyva_Admin will guess wrong, or maybe there is a more specific or custom value type you want to use. The main purpose a column has a type is to turn the raw value from the record into a string or HTML that can be rendered in a grid cell. < column name = \"amount\" type = \"price\" /> For PHP values that can be rendered as strings natively usually no type attribute is required. If the simply string cast is not sufficient, for example, a decimal value representing a currency amount, a simple existing type can be used, e.g. type=\"price\" or type=\"datetime\" so it looks nicer. If a record contains PHP custom objects that can\u2019t be cast to a string, then a custom type is required. There are many existing types you can use as an example. The existing types can be found in the Hyva_Admin module directory Hyva/Admin/Model/DataType . Each type class has to implement the interface HyvaAdminApiDataTypeValueToStringConverterInterface (or HyvaAdminApiDataTypeInterface which inherits the former). More information on the interfaces can be found in the Hyva_Admin PHP type reference. template Sometimes column values require special treatment to be rendered, or maybe multiple column values need to be combined in one cell (e.g. an image URL as a <img src attribute and an image label as the <img alt attribute). For such cases the template attribute is used configure the template to render each cell. The file is specified in the Vendor_Module::file.phtml syntax common in Magento 2. < column name = \"documents\" template = \"My_Module::grid/cell/docs.phtml\" /> In the template, the cell instance that is currently being rendered is automatically injected as the variable $cell . This type hint can be added to the .phtml file to allow autocompletion in IDEs: /** @varHyvaAdminViewModelHyvaGridCellInterface $cell */ renderAsUnsecureHtml By default all cell content is escaped, so no malicious code can be injected. If a cell content needs to be rendered as HTML (for example an image or a link), the attribute renderAsUnsecureHtml=\"true\" has to be specified. < column name = \"image\" type = \"magento_product_image\" renderAsUnsecureHtml = \"true\" /> If renderAsUnsecure is set to true , the data type method DataTypeValueToStringConverterInterface::toHtmlRecursive() is used to fetch a cells content for rendering. If renderAsUnsecure is set to false , the data type method DataTypeValueToStringConverterInterface::toString() is used to fetch a cells content for rendering. rendererBlockName In some cases specifying a template to render a grid cell might not be sufficient. For example, if additional functionality through view models is required, those can not be made available to the template block rendering the cells. To support advanced use cases like this, the layout XML name of a block that is declared somewhere else in the page layout can be set as the renderBlockName. < column name = \"activity\" rendererBlockName = \"activity-renderer-block\" /> The renderer block will be used to render each cell in that column, roughly using code like this: $renderer = $layout->getBlock($rendererBlockName); return $renderer->setData('cell', $this)->toHtml() This PHP code snippet is only shown to further understanding of the internal workings - you don\u2019t have to add this code - all you have to do is declare the renderer block in layout XML, and maybe specify the template it should use. Please note that this block has to be declared in layout XML on every page the grid is used. Please also note that adding a block renderer for a column automatically disables Ajax navigation, because the layout XML that defines the renderer block would not be loaded during the processing of the Ajax navigation request. To access the cell data in the custom renderer, use $this->getData('cell') . If the custom renderer uses a template, the cell can be accessed within the template using $block->getData('cell') . sortOrder Without any include columns configuration, columns are sorted however they are returned by the grid source type class. If include columns are configured, the columns in the grid are rendered in the same order as the grids in the grid XML. If include keepAllSourceColumns=\"true\" is set, all specified include columns are rendered first, and then all remaining available columns are rendered after those. This will take care of at least 80% of all grids. However, maybe you want to change the sort order of a grid that is declared in a different module through XML merging. To support this use case, a sortOrder attribute can be set on columns. Columns are sorted in ascending order, e.g. sortOrder=\"1\" before sortOrder=\"2\" . < column name = \"id\" sortOrder = \"20\" /> < column name = \"sku\" sortOrder = \"10\" /> sortable By default columns are sortable by clicking on the column title, except if the column is based on extension attributes or other linked values that are loaded in a separate query, like the product media_gallery or category_ids attributes. To disable sorting on a column, specify sortable=\"false\" in the grid configuration. < column name = \"sku\" sortable = \"false\" /> source For EAV attributes that use a select or multiselect frontend input, the attribute source model is determined automatically. But if you need to, you can specify an attribute source model with the source column attribute. < column name = \"websites\" source = \"MagentoCustomerModelCustomerAttributeSourceWebsite\" /> The class will then be used to map the column values to the display label. The class has to implement the MagentoEavModelEntityAttributeSourceSourceInterface interface. Note that for simple cases attribute options can also be configured using option child elements. Please refer to the grid:columns:include:column:option documentation for more information. initiallyHidden By default, all columns inside the <include> section will be displayed on the grid the first time it is loaded. If you need to hide a column by initially, but at the same time allow a user to display it in the grid using the \u201cDisplay\u201d dropdown, you can set this attribute to \"true\" . Please note this only affects the initial state of the grid. Once it has been loaded into the browser page, the column display state is stored in session storage. < column name = \"image\" initiallyHidden = \"true\" />","title":"Overview"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#grid-columns-include-column","text":"The include column element allows configuring if column should be displayed or not, and if it is displayed, how the column should be rendered. The include column can have a number of attributes, almost all of which are optional: name (required) label type template renderAsUnsecureHtml rendererBlockName sortOrder sortable source initiallyHidden In the following you can find a description of each column attribute.","title":"grid &gt; columns &gt; include &gt; column"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#name","text":"This is the only required attribute. It specifies the column key that is used to fetch the cell value from the grid source record. < column name = \"sku\" />","title":"name"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#label","text":"The label is shown as the column title. Without a label attribute the title is determined from the column name. < column name = \"image\" label = \"Main Image\" />","title":"label"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#type","text":"The type influences how a column value is rendered in a grid cell. It sometimes can be determined automatically, but then again, sometimes Hyva_Admin will guess wrong, or maybe there is a more specific or custom value type you want to use. The main purpose a column has a type is to turn the raw value from the record into a string or HTML that can be rendered in a grid cell. < column name = \"amount\" type = \"price\" /> For PHP values that can be rendered as strings natively usually no type attribute is required. If the simply string cast is not sufficient, for example, a decimal value representing a currency amount, a simple existing type can be used, e.g. type=\"price\" or type=\"datetime\" so it looks nicer. If a record contains PHP custom objects that can\u2019t be cast to a string, then a custom type is required. There are many existing types you can use as an example. The existing types can be found in the Hyva_Admin module directory Hyva/Admin/Model/DataType . Each type class has to implement the interface HyvaAdminApiDataTypeValueToStringConverterInterface (or HyvaAdminApiDataTypeInterface which inherits the former). More information on the interfaces can be found in the Hyva_Admin PHP type reference.","title":"type"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#template","text":"Sometimes column values require special treatment to be rendered, or maybe multiple column values need to be combined in one cell (e.g. an image URL as a <img src attribute and an image label as the <img alt attribute). For such cases the template attribute is used configure the template to render each cell. The file is specified in the Vendor_Module::file.phtml syntax common in Magento 2. < column name = \"documents\" template = \"My_Module::grid/cell/docs.phtml\" /> In the template, the cell instance that is currently being rendered is automatically injected as the variable $cell . This type hint can be added to the .phtml file to allow autocompletion in IDEs: /** @varHyvaAdminViewModelHyvaGridCellInterface $cell */","title":"template"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#renderasunsecurehtml","text":"By default all cell content is escaped, so no malicious code can be injected. If a cell content needs to be rendered as HTML (for example an image or a link), the attribute renderAsUnsecureHtml=\"true\" has to be specified. < column name = \"image\" type = \"magento_product_image\" renderAsUnsecureHtml = \"true\" /> If renderAsUnsecure is set to true , the data type method DataTypeValueToStringConverterInterface::toHtmlRecursive() is used to fetch a cells content for rendering. If renderAsUnsecure is set to false , the data type method DataTypeValueToStringConverterInterface::toString() is used to fetch a cells content for rendering.","title":"renderAsUnsecureHtml"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#rendererblockname","text":"In some cases specifying a template to render a grid cell might not be sufficient. For example, if additional functionality through view models is required, those can not be made available to the template block rendering the cells. To support advanced use cases like this, the layout XML name of a block that is declared somewhere else in the page layout can be set as the renderBlockName. < column name = \"activity\" rendererBlockName = \"activity-renderer-block\" /> The renderer block will be used to render each cell in that column, roughly using code like this: $renderer = $layout->getBlock($rendererBlockName); return $renderer->setData('cell', $this)->toHtml() This PHP code snippet is only shown to further understanding of the internal workings - you don\u2019t have to add this code - all you have to do is declare the renderer block in layout XML, and maybe specify the template it should use. Please note that this block has to be declared in layout XML on every page the grid is used. Please also note that adding a block renderer for a column automatically disables Ajax navigation, because the layout XML that defines the renderer block would not be loaded during the processing of the Ajax navigation request. To access the cell data in the custom renderer, use $this->getData('cell') . If the custom renderer uses a template, the cell can be accessed within the template using $block->getData('cell') .","title":"rendererBlockName"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#sortorder","text":"Without any include columns configuration, columns are sorted however they are returned by the grid source type class. If include columns are configured, the columns in the grid are rendered in the same order as the grids in the grid XML. If include keepAllSourceColumns=\"true\" is set, all specified include columns are rendered first, and then all remaining available columns are rendered after those. This will take care of at least 80% of all grids. However, maybe you want to change the sort order of a grid that is declared in a different module through XML merging. To support this use case, a sortOrder attribute can be set on columns. Columns are sorted in ascending order, e.g. sortOrder=\"1\" before sortOrder=\"2\" . < column name = \"id\" sortOrder = \"20\" /> < column name = \"sku\" sortOrder = \"10\" />","title":"sortOrder"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#sortable","text":"By default columns are sortable by clicking on the column title, except if the column is based on extension attributes or other linked values that are loaded in a separate query, like the product media_gallery or category_ids attributes. To disable sorting on a column, specify sortable=\"false\" in the grid configuration. < column name = \"sku\" sortable = \"false\" />","title":"sortable"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#source","text":"For EAV attributes that use a select or multiselect frontend input, the attribute source model is determined automatically. But if you need to, you can specify an attribute source model with the source column attribute. < column name = \"websites\" source = \"MagentoCustomerModelCustomerAttributeSourceWebsite\" /> The class will then be used to map the column values to the display label. The class has to implement the MagentoEavModelEntityAttributeSourceSourceInterface interface. Note that for simple cases attribute options can also be configured using option child elements. Please refer to the grid:columns:include:column:option documentation for more information.","title":"source"},{"location":"api-reference/grid-xml-reference/columns/include/column/index.html#initiallyhidden","text":"By default, all columns inside the <include> section will be displayed on the grid the first time it is loaded. If you need to hide a column by initially, but at the same time allow a user to display it in the grid using the \u201cDisplay\u201d dropdown, you can set this attribute to \"true\" . Please note this only affects the initial state of the grid. Once it has been loaded into the browser page, the column display state is stored in session storage. < column name = \"image\" initiallyHidden = \"true\" />","title":"initiallyHidden"},{"location":"api-reference/grid-xml-reference/columns/include/column/option.html","text":"grid > columns > include > column > option For simple use cases it would be too much to create a PHP source model. For example, when a list of websites for a shop is pretty static, it might be enough to just hardcode them in a grid configuration for a column. < column name = \"websites\" > < option value = \"5\" label = \"Spain\" /> < option value = \"2\" label = \"Italy\" /> < option value = \"30\" label = \"Germany\" /> < option value = \"31\" label = \"Poland\" /> < option value = \"5\" label = \"Estonia\" /> </ column > Column values will automatically be mapped from the value to a matching label when options are present. Option values don\u2019t have to be numbers, they can also be string values. The option labels are always passed through the translation function __() before they are rendered.","title":"grid > columns > include > column > option"},{"location":"api-reference/grid-xml-reference/columns/include/column/option.html#grid-columns-include-column-option","text":"For simple use cases it would be too much to create a PHP source model. For example, when a list of websites for a shop is pretty static, it might be enough to just hardcode them in a grid configuration for a column. < column name = \"websites\" > < option value = \"5\" label = \"Spain\" /> < option value = \"2\" label = \"Italy\" /> < option value = \"30\" label = \"Germany\" /> < option value = \"31\" label = \"Poland\" /> < option value = \"5\" label = \"Estonia\" /> </ column > Column values will automatically be mapped from the value to a matching label when options are present. Option values don\u2019t have to be numbers, they can also be string values. The option labels are always passed through the translation function __() before they are rendered.","title":"grid &gt; columns &gt; include &gt; column &gt; option"},{"location":"api-reference/grid-xml-reference/entityconfig/index.html","text":"grid > entityConfig The grid entity configuration is currently only used to specify the labels to display when a grid is empty. < entityConfig > < label > < singular > Product </ singular > < plural > Products </ plural > </ label > </ entityConfig > The above example would render No Products found. If no entityConfig is present, the grid name is used instead. On a grid with the name product-grid, the message would then look like this: No product-grid records found. In future more children elements might be added to the entityConfig element.","title":"Overview"},{"location":"api-reference/grid-xml-reference/entityconfig/index.html#grid-entityconfig","text":"The grid entity configuration is currently only used to specify the labels to display when a grid is empty. < entityConfig > < label > < singular > Product </ singular > < plural > Products </ plural > </ label > </ entityConfig > The above example would render No Products found. If no entityConfig is present, the grid name is used instead. On a grid with the name product-grid, the message would then look like this: No product-grid records found. In future more children elements might be added to the entityConfig element.","title":"grid &gt; entityConfig"},{"location":"api-reference/grid-xml-reference/entityconfig/label/index.html","text":"grid > entityConfig > label The entityConfig label is only used as a parent to group the singular and plural children elements.","title":"Overview"},{"location":"api-reference/grid-xml-reference/entityconfig/label/index.html#grid-entityconfig-label","text":"The entityConfig label is only used as a parent to group the singular and plural children elements.","title":"grid &gt; entityConfig &gt; label"},{"location":"api-reference/grid-xml-reference/entityconfig/label/plural.html","text":"grid > entityConfig > label > plural The entityConfig plural node configures the entity name to render when no records are found for a grid. If no plural label is present, the value of the sibling element singular is used with a s suffix as the default. If both the plural and the singular entity config label is absent, then the grid name is used as a fallback. < entityConfig > < label > < singular > Product </ singular > < plural > Products </ plural > </ label > </ entityConfig >","title":"grid > entityConfig > label > plural"},{"location":"api-reference/grid-xml-reference/entityconfig/label/plural.html#grid-entityconfig-label-plural","text":"The entityConfig plural node configures the entity name to render when no records are found for a grid. If no plural label is present, the value of the sibling element singular is used with a s suffix as the default. If both the plural and the singular entity config label is absent, then the grid name is used as a fallback. < entityConfig > < label > < singular > Product </ singular > < plural > Products </ plural > </ label > </ entityConfig >","title":"grid &gt; entityConfig &gt; label &gt; plural"},{"location":"api-reference/grid-xml-reference/entityconfig/label/singluar.html","text":"grid > entityConfig > label > singluar Please refer to the documentation for the grid > entityConfig > label > plural for information.","title":"grid > entityConfig > label > singluar"},{"location":"api-reference/grid-xml-reference/entityconfig/label/singluar.html#grid-entityconfig-label-singluar","text":"Please refer to the documentation for the grid > entityConfig > label > plural for information.","title":"grid &gt; entityConfig &gt; label &gt; singluar"},{"location":"api-reference/grid-xml-reference/massactions/index.html","text":"grid > massActions Mass actions allow selecting multiple records in a grid and passing their ID values to a target controller. By default no mass actions are present in a grid. When mass actions are configured, an additional column is rendered in leftmost position with a checkbox for each record. Also, a dropdown with all mass actions is added above the grid. As soon as one of the options is selected, the IDs of all selected records are sent to the selected mass action controller. If no records are selected, an alert is displayed instead of triggering the mass action. The massActions element has two optional attributes: idColumn The idColumn attribute specifies the column name that supplies the mass action ID value. If no idColumn is configured, the first grid column is used to supply the record IDs. idsParam The optional idParams attribute is used to configure the name of the query argument that is used to pass the selected ID values to the destination mass action controllers. If no idsParam is specified, the idColumn value is used. Example: < massActions idColumn = \"id\" idsParam = \"productIds\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> </ massActions >","title":"Overview"},{"location":"api-reference/grid-xml-reference/massactions/index.html#grid-massactions","text":"Mass actions allow selecting multiple records in a grid and passing their ID values to a target controller. By default no mass actions are present in a grid. When mass actions are configured, an additional column is rendered in leftmost position with a checkbox for each record. Also, a dropdown with all mass actions is added above the grid. As soon as one of the options is selected, the IDs of all selected records are sent to the selected mass action controller. If no records are selected, an alert is displayed instead of triggering the mass action. The massActions element has two optional attributes:","title":"grid &gt; massActions"},{"location":"api-reference/grid-xml-reference/massactions/index.html#idcolumn","text":"The idColumn attribute specifies the column name that supplies the mass action ID value. If no idColumn is configured, the first grid column is used to supply the record IDs.","title":"idColumn"},{"location":"api-reference/grid-xml-reference/massactions/index.html#idsparam","text":"The optional idParams attribute is used to configure the name of the query argument that is used to pass the selected ID values to the destination mass action controllers. If no idsParam is specified, the idColumn value is used.","title":"idsParam"},{"location":"api-reference/grid-xml-reference/massactions/index.html#example","text":"< massActions idColumn = \"id\" idsParam = \"productIds\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> </ massActions >","title":"Example:"},{"location":"api-reference/grid-xml-reference/massactions/action.html","text":"grid > massActions > action Each massAction action element configures an option in the mass action dropdown. The massAction action has three required and one optional attribute: id The id attribute is used so it is possible to reference mass actions during XML merging. It is not used in rendering. label The label is used to render the option for a mass action in the mass actions dropdown. url The url is used to specify the mass action target. The usual Magento route specification is used, i.e. * is used to reference the current module, action path or action. */*/* refers to the current action that displays the grid. */*/foo refers to the current route, current action path, foo action class.requireConfirmation requireConfirmation By default a mass action is triggered as soon as the option is selected. When requireConfirmation=\"true\" is set, the user is prompted after the option is selected and before the mass action is triggered. This is useful to help avoid the accidental triggering of destructive or expensive operations. Example < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" />","title":"grid > massActions > action"},{"location":"api-reference/grid-xml-reference/massactions/action.html#grid-massactions-action","text":"Each massAction action element configures an option in the mass action dropdown. The massAction action has three required and one optional attribute:","title":"grid &gt; massActions &gt; action"},{"location":"api-reference/grid-xml-reference/massactions/action.html#id","text":"The id attribute is used so it is possible to reference mass actions during XML merging. It is not used in rendering.","title":"id"},{"location":"api-reference/grid-xml-reference/massactions/action.html#label","text":"The label is used to render the option for a mass action in the mass actions dropdown.","title":"label"},{"location":"api-reference/grid-xml-reference/massactions/action.html#url","text":"The url is used to specify the mass action target. The usual Magento route specification is used, i.e. * is used to reference the current module, action path or action. */*/* refers to the current action that displays the grid. */*/foo refers to the current route, current action path, foo action class.requireConfirmation","title":"url"},{"location":"api-reference/grid-xml-reference/massactions/action.html#requireconfirmation","text":"By default a mass action is triggered as soon as the option is selected. When requireConfirmation=\"true\" is set, the user is prompted after the option is selected and before the mass action is triggered. This is useful to help avoid the accidental triggering of destructive or expensive operations.","title":"requireConfirmation"},{"location":"api-reference/grid-xml-reference/massactions/action.html#example","text":"< action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" />","title":"Example"},{"location":"api-reference/grid-xml-reference/navigation/index.html","text":"grid > navigation The grid navigation contains the paging, sorting and filtering grid configuration. There is one attribute, useAjax . < navigation useAjax = \"false\" > < exports > < export type = \"csv\" label = \"Export as CSV\" /> </ exports > < pager > < pageSizes > 2,5,10 </ pageSizes > </ pager > < sorting > < defaultSortByColumn > foo </ defaultSortByColumn > </ sorting > < filters > < filter column = \"sku\" /> </ filters > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" enabled = \"false\" /> </ buttons > </ navigation > By default, grids use Ajax navigation. The useAjax attribute can be used to disable Ajax navigation for a grid. Info If a grid uses a column with a cell renderer via rendererBlockName Ajax paging will be automatically disabled for the grid, too, because the layout XML that defines the renderer block will not be loaded during Ajax navigation request processing. For example: < column name = \"activity\" rendererBlockName = \"myRendererBlock\" /> A column like this will disable Ajax navigation.","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/index.html#grid-navigation","text":"The grid navigation contains the paging, sorting and filtering grid configuration. There is one attribute, useAjax . < navigation useAjax = \"false\" > < exports > < export type = \"csv\" label = \"Export as CSV\" /> </ exports > < pager > < pageSizes > 2,5,10 </ pageSizes > </ pager > < sorting > < defaultSortByColumn > foo </ defaultSortByColumn > </ sorting > < filters > < filter column = \"sku\" /> </ filters > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" enabled = \"false\" /> </ buttons > </ navigation > By default, grids use Ajax navigation. The useAjax attribute can be used to disable Ajax navigation for a grid. Info If a grid uses a column with a cell renderer via rendererBlockName Ajax paging will be automatically disabled for the grid, too, because the layout XML that defines the renderer block will not be loaded during Ajax navigation request processing. For example: < column name = \"activity\" rendererBlockName = \"myRendererBlock\" /> A column like this will disable Ajax navigation.","title":"grid &gt; navigation"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html","text":"grid > navigation > buttons The <buttons> element is used to declare buttons that should be rendered above the grid. < navigation > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" /> < button id = \"refresh\" label = \"Refresh Grid\" onclick = \"window.location.reload(true)\" sortOrder = \"1\" /> < button id = \"sync\" template = \"Module_Name::sync-button.phtml\" enabled = \"false\" /> </ buttons > </ navigation > Buttons can specify the effect they have through either an url or an onclick attribute. They support multiple attributes: id (required) The required id attribute is used to give a button a unique identifier. It can be used to alter a button declaration through XML merging. label The label that will be rendered on the button. The label will be passed through the __() translation method before it is rendered. url The url attribute takes a route declaration in the standard Magento notation of routeid/action_path/action . A * value indicates the current value should be used. There is no way to specify query arguments. onclick With onclick arbitrary JavaScript can be executed when a button is clicked. sortOrder By default buttons are rendered in the order they are declared. Buttons that have a sortOrder attribute are rendered before buttons without this attribute. A smaller number causes a button to be rendered earlier (more to the left). enabled By setting the enabled=\"false\" attribute, buttons can be removed from a grid. Usually this is used through XML merging. template In order to allow uttermost customizability, a custom template can be used to render a button. If a template attribute is specified, the whole HTML for that button has to be rendered by the template .phtml file. For example: < a class = \"btn btn-primary inline-flex mx-2 cursor-pointer\" onclick = \"<?= $button->getOnClick() ?>\" > < span > <?= $escaper->escapeHtml(__($button->getLabel())) ?> </ span > </ a > The button instance is assigned as a template variable. It is helpful to add it to the template as a PHPDoc type hint: /** @varHyvaAdminViewModelHyvaGridGridButtonInterface $button */","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#grid-navigation-buttons","text":"The <buttons> element is used to declare buttons that should be rendered above the grid. < navigation > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" /> < button id = \"refresh\" label = \"Refresh Grid\" onclick = \"window.location.reload(true)\" sortOrder = \"1\" /> < button id = \"sync\" template = \"Module_Name::sync-button.phtml\" enabled = \"false\" /> </ buttons > </ navigation > Buttons can specify the effect they have through either an url or an onclick attribute. They support multiple attributes:","title":"grid &gt; navigation &gt; buttons"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#id-required","text":"The required id attribute is used to give a button a unique identifier. It can be used to alter a button declaration through XML merging.","title":"id (required)"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#label","text":"The label that will be rendered on the button. The label will be passed through the __() translation method before it is rendered.","title":"label"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#url","text":"The url attribute takes a route declaration in the standard Magento notation of routeid/action_path/action . A * value indicates the current value should be used. There is no way to specify query arguments.","title":"url"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#onclick","text":"With onclick arbitrary JavaScript can be executed when a button is clicked.","title":"onclick"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#sortorder","text":"By default buttons are rendered in the order they are declared. Buttons that have a sortOrder attribute are rendered before buttons without this attribute. A smaller number causes a button to be rendered earlier (more to the left).","title":"sortOrder"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#enabled","text":"By setting the enabled=\"false\" attribute, buttons can be removed from a grid. Usually this is used through XML merging.","title":"enabled"},{"location":"api-reference/grid-xml-reference/navigation/buttons/index.html#template","text":"In order to allow uttermost customizability, a custom template can be used to render a button. If a template attribute is specified, the whole HTML for that button has to be rendered by the template .phtml file. For example: < a class = \"btn btn-primary inline-flex mx-2 cursor-pointer\" onclick = \"<?= $button->getOnClick() ?>\" > < span > <?= $escaper->escapeHtml(__($button->getLabel())) ?> </ span > </ a > The button instance is assigned as a template variable. It is helpful to add it to the template as a PHPDoc type hint: /** @varHyvaAdminViewModelHyvaGridGridButtonInterface $button */","title":"template"},{"location":"api-reference/grid-xml-reference/navigation/buttons/button.html","text":"grid > navigation > buttons > button Please refer to the grid > navigation > buttons documentation page for the relevant documentation.","title":"grid > navigation > buttons > button"},{"location":"api-reference/grid-xml-reference/navigation/buttons/button.html#grid-navigation-buttons-button","text":"Please refer to the grid > navigation > buttons documentation page for the relevant documentation.","title":"grid &gt; navigation &gt; buttons &gt; button"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html","text":"grid > navigation > exports The <exports> node is used configure available export types for a grid. < navigation > < exports > < export type = \"csv\" label = \"Export as CSV\" /> < export type = \"xml\" label = \"Export as XML\" enabled = \"false\" /> < export type = \"xlsx\" label = \"Export as XLSX\" /> < export type = \"custom\" label = \"Export as my custom format\" class = \"MyModuleModelCustomGridExport\" fileName = \"example.foo\" sortOrder = \"1\" /> </ exports > </ navigation > Each available type is declared as a child <export> node. Each export is identified by its type. Three types are available out of the box (csv, xml and xlsx). Further information about implementing custom export types can be found in the PHP API reference under Grid AbstractExportType . Attributes The <exports> node has no attributes, but the child several: type (required) The type attribute identifies each configured export. The value is a short string identifier that also usually works as a file name suffix for the export file. label The label for the export link. If it isn\u2019t specified, it defaults to 'Export as ' . mb_strtoupper($this->getType()) . enabled The enabled attribute can be used to disable export types that are declared elsewhere. class The name of the PHP class to generate the export file. Useful only for custom export types. It can also be used to override a default export type implementation. fileName The name of the export file, relative to the export types export dir. Files in subdirectories are supported (e.g. export/export.foo ). If not specified, the grid name plus the export type as the file name suffix is used. sortOrder By default exports are rendered in the order they are found in the configuration. The order can be change with the sortOrder attribute. Export types with a sortOrder will be rendered before export types without a sortOrder attribute.","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#grid-navigation-exports","text":"The <exports> node is used configure available export types for a grid. < navigation > < exports > < export type = \"csv\" label = \"Export as CSV\" /> < export type = \"xml\" label = \"Export as XML\" enabled = \"false\" /> < export type = \"xlsx\" label = \"Export as XLSX\" /> < export type = \"custom\" label = \"Export as my custom format\" class = \"MyModuleModelCustomGridExport\" fileName = \"example.foo\" sortOrder = \"1\" /> </ exports > </ navigation > Each available type is declared as a child <export> node. Each export is identified by its type. Three types are available out of the box (csv, xml and xlsx). Further information about implementing custom export types can be found in the PHP API reference under Grid AbstractExportType .","title":"grid &gt; navigation &gt; exports"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#attributes","text":"The <exports> node has no attributes, but the child several:","title":"Attributes"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#type-required","text":"The type attribute identifies each configured export. The value is a short string identifier that also usually works as a file name suffix for the export file.","title":"type (required)"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#label","text":"The label for the export link. If it isn\u2019t specified, it defaults to 'Export as ' . mb_strtoupper($this->getType()) .","title":"label"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#enabled","text":"The enabled attribute can be used to disable export types that are declared elsewhere.","title":"enabled"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#class","text":"The name of the PHP class to generate the export file. Useful only for custom export types. It can also be used to override a default export type implementation.","title":"class"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#filename","text":"The name of the export file, relative to the export types export dir. Files in subdirectories are supported (e.g. export/export.foo ). If not specified, the grid name plus the export type as the file name suffix is used.","title":"fileName"},{"location":"api-reference/grid-xml-reference/navigation/exports/index.html#sortorder","text":"By default exports are rendered in the order they are found in the configuration. The order can be change with the sortOrder attribute. Export types with a sortOrder will be rendered before export types without a sortOrder attribute.","title":"sortOrder"},{"location":"api-reference/grid-xml-reference/navigation/exports/export.html","text":"grid > navigation > exports > export Please refer to the grid > navigation > exports documentation page for the relevant documentation","title":"grid > navigation > exports > export"},{"location":"api-reference/grid-xml-reference/navigation/exports/export.html#grid-navigation-exports-export","text":"Please refer to the grid > navigation > exports documentation page for the relevant documentation","title":"grid &gt; navigation &gt; exports &gt; export"},{"location":"api-reference/grid-xml-reference/navigation/filters/index.html","text":"grid > navigation > filters The filters configuration is used to specify which columns are filterable. There are a number of different filter types, and custom filters can also be used. < filters > < filter column = \"id\" /> < filter column = \"sku\" /> < filter column = \"activity\" /> </ filters > By default no filters are rendered. The filter type is determined automatically based on a columns type. More information on filter types can be found on the PHP class documentation for HyvaAdminApiGridFilterTypeInterface . Not all column types can automatically be mapped to a filter type. In such cases a filterType class needs to be set on a filter .","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/filters/index.html#grid-navigation-filters","text":"The filters configuration is used to specify which columns are filterable. There are a number of different filter types, and custom filters can also be used. < filters > < filter column = \"id\" /> < filter column = \"sku\" /> < filter column = \"activity\" /> </ filters > By default no filters are rendered. The filter type is determined automatically based on a columns type. More information on filter types can be found on the PHP class documentation for HyvaAdminApiGridFilterTypeInterface . Not all column types can automatically be mapped to a filter type. In such cases a filterType class needs to be set on a filter .","title":"grid &gt; navigation &gt; filters"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html","text":"grid > navigation > filters > filter A filter element enables (or disables) filtering for a column. Unless a filter is configured explicitly, a column is not filterable. < filter column = \"sku\" /> How a filter is rendered and is applied is determined by the column definition: Column type bool \u2192 Filter type boolean Column type datetime \u2192 Filter type date-range Column type int \u2192 Filter type value-range Column with options \u2192 Filter type select All other \u2192 Filter type text There is one exception: if a filter is has options or a source attribute, it will always be rendered as a select filter, regardless of the columns type. It is also possible to create custom filter types (see below). The filter element as one required and four optional attributes. column (required) This attribute refers to the column that should be filterable. The attribute value is the column name. template When the default filter templates are not sufficient, a custom filter template can be specified with the template attribute in the common Magento Vendor_Module:template-file.phtml notation. < filter column = \"images\" template = \"My_Module::grid/filters/image-filter.phtml\" /> The filter instance is injected in the template automatically with the variable $filter . A PHPDoc type hint can be added with the following code to supply IDE auto-completion: /** @varHyvaAdminViewModelHyvaGridGridFilterInterface $filter */ The included templates can be used as a reference and can be found in the Hyva_Admin module directory view/adminhtml/templates/filter . enabled The enabled attribute can be used to disable a filter that was declared in another grid XML configuration. < filter column = \"sku\" enabled = \"false\" /> filterType The filterType attribute is used to specify a custom filter type class. < filter column = \"category_links\" filterType = \"MyModuleAdmihtmlGridFilterCategoryLinksGridFilter\" /> Filter types are responsible for supplying the filter renderer (a template block instance) and for applying filter values to a SearchCriteria instance. All filter types implement the interface HyvaAdminApiGridFilterTypeInterface . More information can be found in the Hyva_Admin PHP Classes and Interfaces reference. source The source attribute is used to specify a source model class or interface to get the select options for the filter. When a source attribute is present, the column filter will always be rendered as a select filter, regardless of the columns type. The only requirement for the source class is it has a toOptionArray method (all Magento source models have that method). This method has to return the options in the usual Magento format [['value' => $value, 'label' => $label], \u2026] . Currently a source model overrides filter options specified in the grid XML, but this behavior is not guaranteed to be stable. < filter column = \"store_id\" source = \"MagentoConfigModelConfigSourceStore\" />","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#grid-navigation-filters-filter","text":"A filter element enables (or disables) filtering for a column. Unless a filter is configured explicitly, a column is not filterable. < filter column = \"sku\" /> How a filter is rendered and is applied is determined by the column definition: Column type bool \u2192 Filter type boolean Column type datetime \u2192 Filter type date-range Column type int \u2192 Filter type value-range Column with options \u2192 Filter type select All other \u2192 Filter type text There is one exception: if a filter is has options or a source attribute, it will always be rendered as a select filter, regardless of the columns type. It is also possible to create custom filter types (see below). The filter element as one required and four optional attributes.","title":"grid &gt; navigation &gt; filters &gt; filter"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#column-required","text":"This attribute refers to the column that should be filterable. The attribute value is the column name.","title":"column (required)"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#template","text":"When the default filter templates are not sufficient, a custom filter template can be specified with the template attribute in the common Magento Vendor_Module:template-file.phtml notation. < filter column = \"images\" template = \"My_Module::grid/filters/image-filter.phtml\" /> The filter instance is injected in the template automatically with the variable $filter . A PHPDoc type hint can be added with the following code to supply IDE auto-completion: /** @varHyvaAdminViewModelHyvaGridGridFilterInterface $filter */ The included templates can be used as a reference and can be found in the Hyva_Admin module directory view/adminhtml/templates/filter .","title":"template"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#enabled","text":"The enabled attribute can be used to disable a filter that was declared in another grid XML configuration. < filter column = \"sku\" enabled = \"false\" />","title":"enabled"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#filtertype","text":"The filterType attribute is used to specify a custom filter type class. < filter column = \"category_links\" filterType = \"MyModuleAdmihtmlGridFilterCategoryLinksGridFilter\" /> Filter types are responsible for supplying the filter renderer (a template block instance) and for applying filter values to a SearchCriteria instance. All filter types implement the interface HyvaAdminApiGridFilterTypeInterface . More information can be found in the Hyva_Admin PHP Classes and Interfaces reference.","title":"filterType"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/index.html#source","text":"The source attribute is used to specify a source model class or interface to get the select options for the filter. When a source attribute is present, the column filter will always be rendered as a select filter, regardless of the columns type. The only requirement for the source class is it has a toOptionArray method (all Magento source models have that method). This method has to return the options in the usual Magento format [['value' => $value, 'label' => $label], \u2026] . Currently a source model overrides filter options specified in the grid XML, but this behavior is not guaranteed to be stable. < filter column = \"store_id\" source = \"MagentoConfigModelConfigSourceStore\" />","title":"source"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/option.html","text":"grid > navigation > filters > filter > option Filter option elements are for one specific use case: when column values are static and don\u2019t warrant the creation of a whole source model. Also, options support grouping multiple values together. < filter column = \"color\" > < option label = \"reddish\" > < value > 16 </ value > < value > 17 </ value > < value > 18 </ value > </ option > < option label = \"blueish\" > < value > 12 </ value > </ option > < option label = \"rose\" > < value > 100 </ value > < value > 103 </ value > </ option > </ filter > When filter options are specified, the filter is always rendered as a select input type. For groups of option values, any record with a matching value will be included in the grid data (internally all values of a selected group are added to the SearchCriteria using an OR condition). The above example would render a filter with three options: reddish , blueish and rose . When reddish is selected, any records with the color attribute matching 16 , 17 or 18 would be shown in the grid. The option values don\u2019t have to be integers, string values are valid, too.","title":"grid > navigation > filters > filter > option"},{"location":"api-reference/grid-xml-reference/navigation/filters/filter/option.html#grid-navigation-filters-filter-option","text":"Filter option elements are for one specific use case: when column values are static and don\u2019t warrant the creation of a whole source model. Also, options support grouping multiple values together. < filter column = \"color\" > < option label = \"reddish\" > < value > 16 </ value > < value > 17 </ value > < value > 18 </ value > </ option > < option label = \"blueish\" > < value > 12 </ value > </ option > < option label = \"rose\" > < value > 100 </ value > < value > 103 </ value > </ option > </ filter > When filter options are specified, the filter is always rendered as a select input type. For groups of option values, any record with a matching value will be included in the grid data (internally all values of a selected group are added to the SearchCriteria using an OR condition). The above example would render a filter with three options: reddish , blueish and rose . When reddish is selected, any records with the color attribute matching 16 , 17 or 18 would be shown in the grid. The option values don\u2019t have to be integers, string values are valid, too.","title":"grid &gt; navigation &gt; filters &gt; filter &gt; option"},{"location":"api-reference/grid-xml-reference/navigation/pager/index.html","text":"grid > navigation > pager The pager configuration is used to configure the default page size and the available page size dropdown. < pager enabled = \"true\" > < defaultPageSize > 40 </ defaultPageSize > < pageSizes > 20,40,100 </ pageSizes > </ pager > When the <pager enabled=\"false\"/> attribute is set, the pager will not be rendered. The \u201cReset Filters\u201d button is still shown above the grid (when filters are active), as is the column Display dropdown.","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/pager/index.html#grid-navigation-pager","text":"The pager configuration is used to configure the default page size and the available page size dropdown. < pager enabled = \"true\" > < defaultPageSize > 40 </ defaultPageSize > < pageSizes > 20,40,100 </ pageSizes > </ pager > When the <pager enabled=\"false\"/> attribute is set, the pager will not be rendered. The \u201cReset Filters\u201d button is still shown above the grid (when filters are active), as is the column Display dropdown.","title":"grid &gt; navigation &gt; pager"},{"location":"api-reference/grid-xml-reference/navigation/pager/defaultpagesize.html","text":"grid > navigation > pager > defaultPageSize The default page size specifies the number of records per page to display initially. With no defaultPageSize configuration the default value 20 is used. < defaultPageSize > 5 </ defaultPageSize >","title":"grid > navigation > pager > defaultPageSize"},{"location":"api-reference/grid-xml-reference/navigation/pager/defaultpagesize.html#grid-navigation-pager-defaultpagesize","text":"The default page size specifies the number of records per page to display initially. With no defaultPageSize configuration the default value 20 is used. < defaultPageSize > 5 </ defaultPageSize >","title":"grid &gt; navigation &gt; pager &gt; defaultPageSize"},{"location":"api-reference/grid-xml-reference/navigation/pager/pagesizes.html","text":"grid > navigation > pager > pageSizes The pageSizes element provides the options for the page size dropdown of a grid. By default the values 10 , 20 and 50 are available. These defaults are defined in the class HyvaAdminViewModelHyvaGridNavigation . < pageSizes > 2,5,10 </ pageSizes >","title":"grid > navigation > pager > pageSizes"},{"location":"api-reference/grid-xml-reference/navigation/pager/pagesizes.html#grid-navigation-pager-pagesizes","text":"The pageSizes element provides the options for the page size dropdown of a grid. By default the values 10 , 20 and 50 are available. These defaults are defined in the class HyvaAdminViewModelHyvaGridNavigation . < pageSizes > 2,5,10 </ pageSizes >","title":"grid &gt; navigation &gt; pager &gt; pageSizes"},{"location":"api-reference/grid-xml-reference/navigation/sorting/index.html","text":"grid > navigation > sorting The sorting node is used to contain the default sort column and the default sort direction configuration. < sorting > < defaultSortByColumn > created_at </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting >","title":"Overview"},{"location":"api-reference/grid-xml-reference/navigation/sorting/index.html#grid-navigation-sorting","text":"The sorting node is used to contain the default sort column and the default sort direction configuration. < sorting > < defaultSortByColumn > created_at </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting >","title":"grid &gt; navigation &gt; sorting"},{"location":"api-reference/grid-xml-reference/navigation/sorting/defaultsortbycolumn.html","text":"grid > navigation > sorting > defaultSortByColumn The defaultSortByColumn element configures the column to sort grid data by initially. Without a defaultSortByColumn element, no sorting is applied to the grid data by default. < defaultSortByColumn > name </ defaultSortByColumn >","title":"grid > navigation > sorting > defaultSortByColumn"},{"location":"api-reference/grid-xml-reference/navigation/sorting/defaultsortbycolumn.html#grid-navigation-sorting-defaultsortbycolumn","text":"The defaultSortByColumn element configures the column to sort grid data by initially. Without a defaultSortByColumn element, no sorting is applied to the grid data by default. < defaultSortByColumn > name </ defaultSortByColumn >","title":"grid &gt; navigation &gt; sorting &gt; defaultSortByColumn"},{"location":"api-reference/grid-xml-reference/navigation/sorting/defaultsortdirection.html","text":"grid > navigation > sorting > defaultSortDirection The defaultSortDirection element specifies the initial sort direction. < defaultSortDirection > desc </ defaultSortDirection > Possible values are asc and desc . Without a defaultSortDirection a grid is sorted in ascending order.","title":"grid > navigation > sorting > defaultSortDirection"},{"location":"api-reference/grid-xml-reference/navigation/sorting/defaultsortdirection.html#grid-navigation-sorting-defaultsortdirection","text":"The defaultSortDirection element specifies the initial sort direction. < defaultSortDirection > desc </ defaultSortDirection > Possible values are asc and desc . Without a defaultSortDirection a grid is sorted in ascending order.","title":"grid &gt; navigation &gt; sorting &gt; defaultSortDirection"},{"location":"api-reference/grid-xml-reference/source/index.html","text":"grid > source Every grid requires a data source. There are different types of grid data providers. Currently supported data providers are: repositoryListMethod arrayProvider collection query More data provider types will be added in future. The next provider type will likely be a SQL query provider. Examples: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > < source > < collection > MagentoCatalogModelResourceModelProductCollection </ collection > </ source > < source > < query > < select > < from table = \"sales_order\" /> </ select > </ query > </ source >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/index.html#grid-source","text":"Every grid requires a data source. There are different types of grid data providers. Currently supported data providers are: repositoryListMethod arrayProvider collection query More data provider types will be added in future. The next provider type will likely be a SQL query provider.","title":"grid &gt; source"},{"location":"api-reference/grid-xml-reference/source/index.html#examples","text":"< source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > < source > < collection > MagentoCatalogModelResourceModelProductCollection </ collection > </ source > < source > < query > < select > < from table = \"sales_order\" /> </ select > </ query > </ source >","title":"Examples:"},{"location":"api-reference/grid-xml-reference/source/arrayprovider.html","text":"grid > source > arrayProvider The arrayProvider node content has to be a fully qualified PHP the class name. The class has to implement the HyvaAdminApiHyvaGridArrayProviderInterface interface. interface HyvaGridArrayProviderInterface { /** * @return array[] */ public function getHyvaGridData(): array; } The method returns an array of records. Each record is a sub array that will be rendered as a row in the grid. The columns are determined based on the array keys of the first record. Example: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source >","title":"grid > source > arrayProvider"},{"location":"api-reference/grid-xml-reference/source/arrayprovider.html#grid-source-arrayprovider","text":"The arrayProvider node content has to be a fully qualified PHP the class name. The class has to implement the HyvaAdminApiHyvaGridArrayProviderInterface interface. interface HyvaGridArrayProviderInterface { /** * @return array[] */ public function getHyvaGridData(): array; } The method returns an array of records. Each record is a sub array that will be rendered as a row in the grid. The columns are determined based on the array keys of the first record.","title":"grid &gt; source &gt; arrayProvider"},{"location":"api-reference/grid-xml-reference/source/arrayprovider.html#example","text":"< source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/collection.html","text":"grid > source > collection The collection node content has to be a fully qualified PHP method with a DB collection class name, meaning the collection has to be a child of the class MagentoFrameworkDataCollectionAbstractDb (probably with some other intermediate classes in between). The collection grid source type uses reflection to determine the fields available on the records. System attributes (a.k.a properties with getter methods) and custom EAV attributes are all displayed as array columns. Example: <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < collection > MagentoCustomerModelResourceModelCustomerCollection </ collection > </ source > </ grid >","title":"grid > source > collection"},{"location":"api-reference/grid-xml-reference/source/collection.html#grid-source-collection","text":"The collection node content has to be a fully qualified PHP method with a DB collection class name, meaning the collection has to be a child of the class MagentoFrameworkDataCollectionAbstractDb (probably with some other intermediate classes in between). The collection grid source type uses reflection to determine the fields available on the records. System attributes (a.k.a properties with getter methods) and custom EAV attributes are all displayed as array columns.","title":"grid &gt; source &gt; collection"},{"location":"api-reference/grid-xml-reference/source/collection.html#example","text":"<?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < collection > MagentoCustomerModelResourceModelCustomerCollection </ collection > </ source > </ grid >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/repositorylistmethod.html","text":"grid > source > repositoryListMethod The repositoryListMethod node content has to be a fully qualified PHP method with the class name. The method has to take a MagentoFrameworkApiSearchCriteriaInterface as an argument, and return a MagentoFrameworkApiSearchResultsInterface . The method name does not have to be getList , even though that is the most common name for this type of method in Magento. The repository grid source type uses reflection to determine the fields available on the records. System attributes, custom EAV attributes and extension attributes are all displayed as array columns. Example: <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > </ grid >","title":"grid > source > repositoryListMethod"},{"location":"api-reference/grid-xml-reference/source/repositorylistmethod.html#grid-source-repositorylistmethod","text":"The repositoryListMethod node content has to be a fully qualified PHP method with the class name. The method has to take a MagentoFrameworkApiSearchCriteriaInterface as an argument, and return a MagentoFrameworkApiSearchResultsInterface . The method name does not have to be getList , even though that is the most common name for this type of method in Magento. The repository grid source type uses reflection to determine the fields available on the records. System attributes, custom EAV attributes and extension attributes are all displayed as array columns.","title":"grid &gt; source &gt; repositoryListMethod"},{"location":"api-reference/grid-xml-reference/source/repositorylistmethod.html#example","text":"<?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > </ grid >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/index.html","text":"grid > source > defaultSearchCriteriaBindings The defaultSearchCriteriaBindings is used to specify automatic search criteria filters against application state. Often a grid is embedded in a page with additional data, e.g. on a customer detail page all their pending reviews could be shown, or on a product page I want to show all orders. In a nutshell, there needs to be some default limitation of the displayed data, that is, I want to show the orders related to the current product. This is what defaultSearchCriteriaBindings is for. The element can contain zero or more <field> nodes.","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/index.html#grid-source-defaultsearchcriteriabindings","text":"The defaultSearchCriteriaBindings is used to specify automatic search criteria filters against application state. Often a grid is embedded in a page with additional data, e.g. on a customer detail page all their pending reviews could be shown, or on a product page I want to show all orders. In a nutshell, there needs to be some default limitation of the displayed data, that is, I want to show the orders related to the current product. This is what defaultSearchCriteriaBindings is for. The element can contain zero or more <field> nodes.","title":"grid &gt; source &gt; defaultSearchCriteriaBindings"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html","text":"grid > source > defaultSearchCriteriaBindings > field Each field element is used to declare a default automatic binding on the SearchCriteria instance that is used when loading the grid source, against some value in the current Magento state. This is mainly useful for showing grids that are embedded in pages of another entity type, for example all orders of a customer. < source > ... < defaultSearchCriteriaBindings > < field name = \"entity_id\" requestParam = \"id\" > < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" /> < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> < field name = \"customer_ids\" condition = \"finset\" method = \"MagentoCustomerModelSession::getCustomerId\" /> </ defaultSearchCriteriaBindings > </ source > There are several possible attributes: name (required) The name attribute specifies the field name for the filter. requestParam This attribute is used to bind the filter to a request value. This is the most common binding type. It is a shorthand for specifying class=\"MagentoFrameworkAppRequestInterface\" and method=\"getParam\" together with a param attribute. method The method attribute is used to specify the class and method to call to product the filter value. < field name = \"customer_id\" method = \"MagentoCustomerModelSession::getCustomerId\" /> param If the method requires a string parameter to produce the desired value, it can be specified with the param attribute. This is sometimes handy for use with the generic getData($key) method. < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" /> property Should the method return an array or an object, the property attribute can be used to retrieve a singe value. < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> The way the property is retrieved depends on the type of value the method returns. For objects the code will try to call a matching getter method, will try getData , a public property or ArrayAccess . For arrays it will simply try to use the property as an array index. condition By default search criteria bindings are applied using an equality condition ( eq ). Using the condition attribute it is possible to use a different condition. Any of the Magento SearchCriteria condition values is allowed: eq is neq lteq from to gteq moreeq gt lt like nlike in nin notnull null finset","title":"grid > source > defaultSearchCriteriaBindings > field"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#grid-source-defaultsearchcriteriabindings-field","text":"Each field element is used to declare a default automatic binding on the SearchCriteria instance that is used when loading the grid source, against some value in the current Magento state. This is mainly useful for showing grids that are embedded in pages of another entity type, for example all orders of a customer. < source > ... < defaultSearchCriteriaBindings > < field name = \"entity_id\" requestParam = \"id\" > < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" /> < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> < field name = \"customer_ids\" condition = \"finset\" method = \"MagentoCustomerModelSession::getCustomerId\" /> </ defaultSearchCriteriaBindings > </ source > There are several possible attributes:","title":"grid &gt; source &gt; defaultSearchCriteriaBindings &gt; field"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#name-required","text":"The name attribute specifies the field name for the filter.","title":"name (required)"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#requestparam","text":"This attribute is used to bind the filter to a request value. This is the most common binding type. It is a shorthand for specifying class=\"MagentoFrameworkAppRequestInterface\" and method=\"getParam\" together with a param attribute.","title":"requestParam"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#method","text":"The method attribute is used to specify the class and method to call to product the filter value. < field name = \"customer_id\" method = \"MagentoCustomerModelSession::getCustomerId\" />","title":"method"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#param","text":"If the method requires a string parameter to produce the desired value, it can be specified with the param attribute. This is sometimes handy for use with the generic getData($key) method. < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" />","title":"param"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#property","text":"Should the method return an array or an object, the property attribute can be used to retrieve a singe value. < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> The way the property is retrieved depends on the type of value the method returns. For objects the code will try to call a matching getter method, will try getData , a public property or ArrayAccess . For arrays it will simply try to use the property as an array index.","title":"property"},{"location":"api-reference/grid-xml-reference/source/defaultsearchcriteriabindings/field.html#condition","text":"By default search criteria bindings are applied using an equality condition ( eq ). Using the condition attribute it is possible to use a different condition. Any of the Magento SearchCriteria condition values is allowed: eq is neq lteq from to gteq moreeq gt lt like nlike in nin notnull null finset","title":"condition"},{"location":"api-reference/grid-xml-reference/source/processors/index.html","text":"grid > source > processors The <processors> node contains the list of HyvaGridSourceProcessorInterface class names that should be applied to the grid (in <processor> child nodes). The <processors> element has no arguments. < source > < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" /> </ processors > </ source >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/processors/index.html#grid-source-processors","text":"The <processors> node contains the list of HyvaGridSourceProcessorInterface class names that should be applied to the grid (in <processor> child nodes). The <processors> element has no arguments. < source > < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" /> </ processors > </ source >","title":"grid &gt; source &gt; processors"},{"location":"api-reference/grid-xml-reference/source/processors/processor.html","text":"grid > source > processors > processor The node defines the class name of HyvaGridSourceProcessorInterface implementations that should be applied to the current grid. < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" enabled = \"false\" /> </ processors > Attributes class (required) The class attribute takes the fully qualified class name or the HyvaAdminApiHyvaGridSourceProcessorInterface implementation. Often the classes don\u2019t implement the interface directly, but instead extend from HyvaAdminModelGridSourceAbstractGridSourceProcessor . More information on grid source processors can be found in the grid walkthrough documentation. enabled The optional enabled attribute can be used to disable processors that have been declared in different modules. It\u2019s value defaults to true .","title":"grid > source > processors > processor"},{"location":"api-reference/grid-xml-reference/source/processors/processor.html#grid-source-processors-processor","text":"The node defines the class name of HyvaGridSourceProcessorInterface implementations that should be applied to the current grid. < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" enabled = \"false\" /> </ processors >","title":"grid &gt; source &gt; processors &gt; processor"},{"location":"api-reference/grid-xml-reference/source/processors/processor.html#attributes","text":"","title":"Attributes"},{"location":"api-reference/grid-xml-reference/source/processors/processor.html#class-required","text":"The class attribute takes the fully qualified class name or the HyvaAdminApiHyvaGridSourceProcessorInterface implementation. Often the classes don\u2019t implement the interface directly, but instead extend from HyvaAdminModelGridSourceAbstractGridSourceProcessor . More information on grid source processors can be found in the grid walkthrough documentation.","title":"class (required)"},{"location":"api-reference/grid-xml-reference/source/processors/processor.html#enabled","text":"The optional enabled attribute can be used to disable processors that have been declared in different modules. It\u2019s value defaults to true .","title":"enabled"},{"location":"api-reference/grid-xml-reference/source/query/index.html","text":"grid > source > query The query grid source configuration can be used to display the contents of a database table directly in a grid, without using intermediate PHP classes like an ORM collection or a repository. The minimum configuration requires only a table name, but it is possible to specify the columns to select, use group by, joins and union selects, too. Initial filters can be declared using the defaultSearchCriteriaBindings source configuration. Attributes: There is one optional attribute: unionSelectType The unionSelectType attribute specifies the type of union select to use. If there are no <unionSelect> children the attribute has no effect. A valid value is one of all or distinct . If no union select type is configured, all will be used by default. The <query> element must have one <select> child element and can have zero or more <unionSelect> element children. Example: <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < query unionSelectType = \"all\" > < select > < from table = \"sales_order\" /> < columns > < column name = \"status\" as = \"order_status\" /> < column name = \"state\" as = \"order_state\" /> < column name = \"created_at\" as = \"latest_order\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns > < groupBy > < column name = \"status\" /> < column name = \"state\" /> </ groupBy > </ select > < unionSelect > < from table = \"some_other_table_with_4_columns\" > </ unionSelect > </ query > </ source > </ grid >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/query/index.html#grid-source-query","text":"The query grid source configuration can be used to display the contents of a database table directly in a grid, without using intermediate PHP classes like an ORM collection or a repository. The minimum configuration requires only a table name, but it is possible to specify the columns to select, use group by, joins and union selects, too. Initial filters can be declared using the defaultSearchCriteriaBindings source configuration.","title":"grid &gt; source &gt; query"},{"location":"api-reference/grid-xml-reference/source/query/index.html#attributes","text":"There is one optional attribute: unionSelectType The unionSelectType attribute specifies the type of union select to use. If there are no <unionSelect> children the attribute has no effect. A valid value is one of all or distinct . If no union select type is configured, all will be used by default. The <query> element must have one <select> child element and can have zero or more <unionSelect> element children.","title":"Attributes:"},{"location":"api-reference/grid-xml-reference/source/query/index.html#example","text":"<?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < query unionSelectType = \"all\" > < select > < from table = \"sales_order\" /> < columns > < column name = \"status\" as = \"order_status\" /> < column name = \"state\" as = \"order_state\" /> < column name = \"created_at\" as = \"latest_order\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns > < groupBy > < column name = \"status\" /> < column name = \"state\" /> </ groupBy > </ select > < unionSelect > < from table = \"some_other_table_with_4_columns\" > </ unionSelect > </ query > </ source > </ grid >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/unionselect.html","text":"grid > source > query > unionSelect A query can have zero or more unionSelect children. The unionSelect element has no attributes. It can contain all the configuration from the <select> attribute. The specified select will be combined with the primary select configuration in a union select. The type of the union select ( UNION DISTINCT or UNION ALL ) can be set with the unionSelectType attribute on the <query> element. If no unionSelectType is configured, the default UNION ALL is used. Please refer to the grid > source > query > select documentation for more information on the allowed children elements.","title":"grid > source > query > unionSelect"},{"location":"api-reference/grid-xml-reference/source/query/unionselect.html#grid-source-query-unionselect","text":"A query can have zero or more unionSelect children. The unionSelect element has no attributes. It can contain all the configuration from the <select> attribute. The specified select will be combined with the primary select configuration in a union select. The type of the union select ( UNION DISTINCT or UNION ALL ) can be set with the unionSelectType attribute on the <query> element. If no unionSelectType is configured, the default UNION ALL is used. Please refer to the grid > source > query > select documentation for more information on the allowed children elements.","title":"grid &gt; source &gt; query &gt; unionSelect"},{"location":"api-reference/grid-xml-reference/source/query/select/index.html","text":"grid > source > query > select The <select> element contains the configuration for the main grid query. There is one required child element and three optional children: from (required) columns join groupBy Example: < select > < from table = \"sales_order\" /> </ select >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/query/select/index.html#grid-source-query-select","text":"The <select> element contains the configuration for the main grid query. There is one required child element and three optional children: from (required) columns join groupBy","title":"grid &gt; source &gt; query &gt; select"},{"location":"api-reference/grid-xml-reference/source/query/select/index.html#example","text":"< select > < from table = \"sales_order\" /> </ select >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/from.html","text":"grid > source > query > select > from The <from> element specifies the table to query. It is the only required child of the parent <select> . It has no children. Attributes: The <from> element has a required table attribute an an optional as attribute to specify an alias for the table. Example: < from table = \"catalog_product_entity\" as = \"main_table\" />","title":"grid > source > query > select > from"},{"location":"api-reference/grid-xml-reference/source/query/select/from.html#grid-source-query-select-from","text":"The <from> element specifies the table to query. It is the only required child of the parent <select> . It has no children.","title":"grid &gt; source &gt; query &gt; select &gt; from"},{"location":"api-reference/grid-xml-reference/source/query/select/from.html#attributes","text":"The <from> element has a required table attribute an an optional as attribute to specify an alias for the table.","title":"Attributes:"},{"location":"api-reference/grid-xml-reference/source/query/select/from.html#example","text":"< from table = \"catalog_product_entity\" as = \"main_table\" />","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/groupby.html","text":"grid > source > query > select > groupBy The <groupBy> element is used to configure the grouping of a query result. It has no attributes and can have zero or more <column> child attributes. Example: < groupBy > < column name = \"status\" /> </ groupBy >","title":"grid > source > query > select > groupBy"},{"location":"api-reference/grid-xml-reference/source/query/select/groupby.html#grid-source-query-select-groupby","text":"The <groupBy> element is used to configure the grouping of a query result. It has no attributes and can have zero or more <column> child attributes.","title":"grid &gt; source &gt; query &gt; select &gt; groupBy"},{"location":"api-reference/grid-xml-reference/source/query/select/groupby.html#example","text":"< groupBy > < column name = \"status\" /> </ groupBy >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/index.html","text":"grid > source > query > select > columns The <columns> element wraps all the columns to be selected from the table that was specified with the <from> element. It takes zero or more <column> or <expression> child elements. If no <columns> are configured, all columns will be included in the result set (e.g. SELECT * FROM table ). Example: < columns > < column name = \"status\" as = \"order_status\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/index.html#grid-source-query-select-columns","text":"The <columns> element wraps all the columns to be selected from the table that was specified with the <from> element. It takes zero or more <column> or <expression> child elements. If no <columns> are configured, all columns will be included in the result set (e.g. SELECT * FROM table ).","title":"grid &gt; source &gt; query &gt; select &gt; columns"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/index.html#example","text":"< columns > < column name = \"status\" as = \"order_status\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/column.html","text":"grid > source > query > select > columns > column The select <column> element is used to add a column of the select table to the query result set. Attributes: There is one required and one optional attribute: name (required) The name attribute specifies the column name to include in the result. * as The as attribute specifies the alias to use for the column. Example: < column name = \"entity_id\" as = \"id\" />","title":"grid > source > query > select > columns > column"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/column.html#grid-source-query-select-columns-column","text":"The select <column> element is used to add a column of the select table to the query result set.","title":"grid &gt; source &gt; query &gt; select &gt; columns &gt; column"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/column.html#attributes","text":"There is one required and one optional attribute: name (required) The name attribute specifies the column name to include in the result. * as The as attribute specifies the alias to use for the column.","title":"Attributes:"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/column.html#example","text":"< column name = \"entity_id\" as = \"id\" />","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/expression.html","text":"grid > source > query > select > columns > expression The <expression> element is used to configure an SQL expression that will be included in the select result. The content of the expression element is not validated. It will be wrapped in a Zend_Db_Expr instance and added to the select instance unmodified. Attributes: It takes one optional Attribute: as The as attribute is used to specify an alias name for the expression column in the result. Example: < expression as = \"count\" > COUNT(*) </ expression >","title":"grid > source > query > select > columns > expression"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/expression.html#grid-source-query-select-columns-expression","text":"The <expression> element is used to configure an SQL expression that will be included in the select result. The content of the expression element is not validated. It will be wrapped in a Zend_Db_Expr instance and added to the select instance unmodified.","title":"grid &gt; source &gt; query &gt; select &gt; columns &gt; expression"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/expression.html#attributes","text":"It takes one optional Attribute: as The as attribute is used to specify an alias name for the expression column in the result.","title":"Attributes:"},{"location":"api-reference/grid-xml-reference/source/query/select/columns/expression.html#example","text":"< expression as = \"count\" > COUNT(*) </ expression >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/join/index.html","text":"grid > source > query > select > join The <join> element is used to configure how to join other tables into the result data set. Attributes There are three join attributes: type The type attribute is used to specify the type of join. A valid value is one of: inner , left , right , full , cross and natural . If no type attribute is present, the default left is used. table (required) The table attribute specifies the name of the table to join. as The attribute as can be used to specify an alias for the joined table. It has one required <on> child element and one optional <columns> child element. Example: < join type = \"left\" table = \"catalog_product_entity_varchar\" as = \"t_name\" > < on > t_name.entity_id=main_table.entity_id AND attribute_id=47 </ on > < columns > < column name = \"value\" as = \"name\" /> </ columns > </ join >","title":"Overview"},{"location":"api-reference/grid-xml-reference/source/query/select/join/index.html#grid-source-query-select-join","text":"The <join> element is used to configure how to join other tables into the result data set.","title":"grid &gt; source &gt; query &gt; select &gt; join"},{"location":"api-reference/grid-xml-reference/source/query/select/join/index.html#attributes","text":"There are three join attributes: type The type attribute is used to specify the type of join. A valid value is one of: inner , left , right , full , cross and natural . If no type attribute is present, the default left is used. table (required) The table attribute specifies the name of the table to join. as The attribute as can be used to specify an alias for the joined table. It has one required <on> child element and one optional <columns> child element.","title":"Attributes"},{"location":"api-reference/grid-xml-reference/source/query/select/join/index.html#example","text":"< join type = \"left\" table = \"catalog_product_entity_varchar\" as = \"t_name\" > < on > t_name.entity_id=main_table.entity_id AND attribute_id=47 </ on > < columns > < column name = \"value\" as = \"name\" /> </ columns > </ join >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/join/columns.html","text":"grid > source > query > select > join > columns The <columns> element wraps all the columns to be selected from a joined table that was specified with the <join table=\u201d\u2026\u201d> element. It takes zero or more <column> or <expression> child elements. (Note: the <columns> element nested under <join> works the same as the <columns> element that is nested under <select> ). If no join <columns> are configured, no columns will be included in the result set from the joined table (this is different from the default <select> columns). Example: < columns > < column name = \"status\" as = \"order_status\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns >","title":"grid > source > query > select > join > columns"},{"location":"api-reference/grid-xml-reference/source/query/select/join/columns.html#grid-source-query-select-join-columns","text":"The <columns> element wraps all the columns to be selected from a joined table that was specified with the <join table=\u201d\u2026\u201d> element. It takes zero or more <column> or <expression> child elements. (Note: the <columns> element nested under <join> works the same as the <columns> element that is nested under <select> ). If no join <columns> are configured, no columns will be included in the result set from the joined table (this is different from the default <select> columns).","title":"grid &gt; source &gt; query &gt; select &gt; join &gt; columns"},{"location":"api-reference/grid-xml-reference/source/query/select/join/columns.html#example","text":"< columns > < column name = \"status\" as = \"order_status\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns >","title":"Example:"},{"location":"api-reference/grid-xml-reference/source/query/select/join/on.html","text":"grid > source > query > select > join > on The <on> attribute is a child of the <join> element. It is used to specify the join condition. There are no attributes and no child elements. Example: < on > t_name.entity_id=main_table.entity_id AND attribute_id=47 </ on >","title":"grid > source > query > select > join > on"},{"location":"api-reference/grid-xml-reference/source/query/select/join/on.html#grid-source-query-select-join-on","text":"The <on> attribute is a child of the <join> element. It is used to specify the join condition. There are no attributes and no child elements.","title":"grid &gt; source &gt; query &gt; select &gt; join &gt; on"},{"location":"api-reference/grid-xml-reference/source/query/select/join/on.html#example","text":"< on > t_name.entity_id=main_table.entity_id AND attribute_id=47 </ on >","title":"Example:"},{"location":"api-reference/php-classes-and-interfaces/index.html","text":"PHP Classes and Interfaces The nested documents describe the PHP classes and interfaces you might interact with in some way while using Hyva_Admin. The interfaces intended for implementation can be found in the Hyva_Admin module directory Api/ . Chances are you will never need to do this. But if you do, well, you can. Currently these are (in alphabetical order, together with the probability you might want to implement them): HyvaAdminApiDataTypeGuesserInterface (very unlikely) HyvaAdminApiDataTypeInterface (very unlikely) HyvaAdminApiDataTypeValueToStringConverterInterface (maybe) HyvaAdminApiHyvaGridArrayProviderInterface (likely) HyvaAdminApiHyvaGridFilterTypeInterface (unlikely) HyvaAdminApiHyvaGridSourceProcessorInterface (unlikely) HyvaAdminModelGridExportTypeAbstractExportType (maybe) HyvaAdminModelGridSourceAbstractGridSourceProcessor (likely) Each of the above interfaces is document in this section of the API reference. There also are a number of classes and interfaces that are not intended to be implemented, but only to be used, mostly when creating custom cell and filter templates: These mostly are (in alphabetical order): HyvaAdminBlockAdminhtmlHyvaGrid (only when declaring the grid block in layout XML) HyvaAdminViewModelHyvaGridCellInterface (in cell templates) HyvaAdminViewModelHyvaGridColumnDefinitionInterface (in cell and filter templates) HyvaAdminViewModelHyvaGridGridFilterInterface (in filter templates) These classes are not documented, however, the only point of contact will be inside of template files. Adding a PHPDoc type hint to the template will allow IDE auto-completion to assist you. Hopefully you will find the method names to be nice and descriptive, and you will always be able to refer to the templates supplied as part of Hyva_Admin as a reference.","title":"Overview"},{"location":"api-reference/php-classes-and-interfaces/index.html#php-classes-and-interfaces","text":"The nested documents describe the PHP classes and interfaces you might interact with in some way while using Hyva_Admin. The interfaces intended for implementation can be found in the Hyva_Admin module directory Api/ . Chances are you will never need to do this. But if you do, well, you can. Currently these are (in alphabetical order, together with the probability you might want to implement them): HyvaAdminApiDataTypeGuesserInterface (very unlikely) HyvaAdminApiDataTypeInterface (very unlikely) HyvaAdminApiDataTypeValueToStringConverterInterface (maybe) HyvaAdminApiHyvaGridArrayProviderInterface (likely) HyvaAdminApiHyvaGridFilterTypeInterface (unlikely) HyvaAdminApiHyvaGridSourceProcessorInterface (unlikely) HyvaAdminModelGridExportTypeAbstractExportType (maybe) HyvaAdminModelGridSourceAbstractGridSourceProcessor (likely) Each of the above interfaces is document in this section of the API reference. There also are a number of classes and interfaces that are not intended to be implemented, but only to be used, mostly when creating custom cell and filter templates: These mostly are (in alphabetical order): HyvaAdminBlockAdminhtmlHyvaGrid (only when declaring the grid block in layout XML) HyvaAdminViewModelHyvaGridCellInterface (in cell templates) HyvaAdminViewModelHyvaGridColumnDefinitionInterface (in cell and filter templates) HyvaAdminViewModelHyvaGridGridFilterInterface (in filter templates) These classes are not documented, however, the only point of contact will be inside of template files. Adding a PHPDoc type hint to the template will allow IDE auto-completion to assist you. Hopefully you will find the method names to be nice and descriptive, and you will always be able to refer to the templates supplied as part of Hyva_Admin as a reference.","title":"PHP Classes and Interfaces"},{"location":"api-reference/php-classes-and-interfaces/abstractgridsourceprocessor.html","text":"AbstractGridSourceProcessor The HyvaAdminModelGridSourceAbstractGridSourceProcessor can be extended to allow low level access to the grid source and the grid result. /** * Generic parent implementation of HyvaGridSourceProcessorInterface. * * Extend this class if you don't need both methods in your processor. * * If extending this class, you don't need to also call this parent class methods. */ abstract class AbstractGridSourceProcessor implements HyvaGridSourceProcessorInterface { public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void { } public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName) { return $rawResult; } } It is enough to implement the HyvaGridSourceProcessorInterface when building custom processors, but if only one of the methods is needed, extending the AbstractGridSourceProcessor will allow overriding only the method that is needed, and using the default null-op implementation for the other. More information on grid source processors can be found in the Grid Walkthrough documentation.","title":"AbstractGridSourceProcessor"},{"location":"api-reference/php-classes-and-interfaces/abstractgridsourceprocessor.html#abstractgridsourceprocessor","text":"The HyvaAdminModelGridSourceAbstractGridSourceProcessor can be extended to allow low level access to the grid source and the grid result. /** * Generic parent implementation of HyvaGridSourceProcessorInterface. * * Extend this class if you don't need both methods in your processor. * * If extending this class, you don't need to also call this parent class methods. */ abstract class AbstractGridSourceProcessor implements HyvaGridSourceProcessorInterface { public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void { } public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName) { return $rawResult; } } It is enough to implement the HyvaGridSourceProcessorInterface when building custom processors, but if only one of the methods is needed, extending the AbstractGridSourceProcessor will allow overriding only the method that is needed, and using the default null-op implementation for the other. More information on grid source processors can be found in the Grid Walkthrough documentation.","title":"AbstractGridSourceProcessor"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html","text":"DataTypeGuesserInterface The DataTypeGuesserInterface is used to determine the column type given a value or a Magento type. The column type in turn is used to figure out how to render a value in a grid. Overview Most of the time this interface is not implemented directly, but instead the DataTypeInterface is implemented instead which combines the DataTypeGuesserInterface with the DataTypeValueToStringConverterInterface . <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; interface DataTypeGuesserInterface { public function valueToTypeCode ( $value ) : ? string ; public function typeToTypeCode ( string $type ) : ? string ; } All DataTypeGuesser implementations are registered with the DataTypeFacade in the adminhtml di.xml configuration. The order of data type guessers matter - more generic types should come later in the list. Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration: < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > < item name = \"magento_product\" xsi:type = \"string\" > HyvaAdminModelDataTypeProductDataType </ item > ... </ argument > </ arguments > </ type > Probably you will never need to implement this interface, unless you want to contribute to Hyva_Admin and add support for a standard Magento data type. Interface Methods valueToTypeCode($value): ?string The method takes a value that could be anything: null, a string, int, object or anything else. If the value is the target type the class can handle, then the method returns an identifying column type code, otherwise it should return null . Example: public function valueToTypeCode($value): ?string { return is_object($value) && $value instanceof AddressInterface ? 'magento_customer_address' : null; } In this example the method returns the column type magento_customer_address when a customer address instance is used as the input value. typeToTypeCode(string $type): ?string The method takes a Magento internal type identifier. It could be a class or interface name, or an EAV attribute backend type code, or a special case like gallery . If the string $type identifies the target type the class can handle, the method should return an identifying column type code, otherwise it should return null . Example: public function typeToTypeCode(string $type): ?string { return is_string($type) && is_subclass_of($type, AddressInterface::class) ? 'magento_customer_address' : null; } In this example the method returns the column type magento_customer_address when $type identifies a class implementing the customer address interface.","title":"DataTypeGuesserInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html#datatypeguesserinterface","text":"The DataTypeGuesserInterface is used to determine the column type given a value or a Magento type. The column type in turn is used to figure out how to render a value in a grid.","title":"DataTypeGuesserInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html#overview","text":"Most of the time this interface is not implemented directly, but instead the DataTypeInterface is implemented instead which combines the DataTypeGuesserInterface with the DataTypeValueToStringConverterInterface . <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; interface DataTypeGuesserInterface { public function valueToTypeCode ( $value ) : ? string ; public function typeToTypeCode ( string $type ) : ? string ; } All DataTypeGuesser implementations are registered with the DataTypeFacade in the adminhtml di.xml configuration. The order of data type guessers matter - more generic types should come later in the list. Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration: < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > < item name = \"magento_product\" xsi:type = \"string\" > HyvaAdminModelDataTypeProductDataType </ item > ... </ argument > </ arguments > </ type > Probably you will never need to implement this interface, unless you want to contribute to Hyva_Admin and add support for a standard Magento data type.","title":"Overview"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html#interface-methods","text":"","title":"Interface Methods"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html#valuetotypecodevalue-string","text":"The method takes a value that could be anything: null, a string, int, object or anything else. If the value is the target type the class can handle, then the method returns an identifying column type code, otherwise it should return null . Example: public function valueToTypeCode($value): ?string { return is_object($value) && $value instanceof AddressInterface ? 'magento_customer_address' : null; } In this example the method returns the column type magento_customer_address when a customer address instance is used as the input value.","title":"valueToTypeCode($value): ?string"},{"location":"api-reference/php-classes-and-interfaces/datatypeguesserinterface.html#typetotypecodestring-type-string","text":"The method takes a Magento internal type identifier. It could be a class or interface name, or an EAV attribute backend type code, or a special case like gallery . If the string $type identifies the target type the class can handle, the method should return an identifying column type code, otherwise it should return null . Example: public function typeToTypeCode(string $type): ?string { return is_string($type) && is_subclass_of($type, AddressInterface::class) ? 'magento_customer_address' : null; } In this example the method returns the column type magento_customer_address when $type identifies a class implementing the customer address interface.","title":"typeToTypeCode(string $type): ?string"},{"location":"api-reference/php-classes-and-interfaces/datatypeinterface.html","text":"DataTypeInterface This interface is used to implement most of the built in Magento data types that Hyva_Admin can automatically determine. It combines the interfaces HyvaAdminApiDataTypeGuesserInterface and HyvaAdminApiDataTypeValueToStringConverterInterface for convenience. All implementations must be registered with the HyvaAdminModelDataTypeDataTypeFacade in the adminhtml di.xml configuration. Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration: < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > <!-- note: order matters - generic DataTypes (e.g. object, unknown) come after more specific ones --> < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > ... < item name = \"magento_tier_price\" xsi:type = \"string\" > HyvaAdminModelDataTypeTierPriceDataType </ item > < item name = \"object\" xsi:type = \"string\" > HyvaAdminModelDataTypeGenericObjectDataType </ item > < item name = \"unknown\" xsi:type = \"string\" > HyvaAdminModelDataTypeUnknownDataType </ item > </ argument > </ arguments > </ type > Please refer to the documentation of the DataTypeGuesserInterface and the DataTypeValueToStringConverterInterface for further information.","title":"DataTypeInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypeinterface.html#datatypeinterface","text":"This interface is used to implement most of the built in Magento data types that Hyva_Admin can automatically determine. It combines the interfaces HyvaAdminApiDataTypeGuesserInterface and HyvaAdminApiDataTypeValueToStringConverterInterface for convenience. All implementations must be registered with the HyvaAdminModelDataTypeDataTypeFacade in the adminhtml di.xml configuration. Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration: < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > <!-- note: order matters - generic DataTypes (e.g. object, unknown) come after more specific ones --> < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > ... < item name = \"magento_tier_price\" xsi:type = \"string\" > HyvaAdminModelDataTypeTierPriceDataType </ item > < item name = \"object\" xsi:type = \"string\" > HyvaAdminModelDataTypeGenericObjectDataType </ item > < item name = \"unknown\" xsi:type = \"string\" > HyvaAdminModelDataTypeUnknownDataType </ item > </ argument > </ arguments > </ type > Please refer to the documentation of the DataTypeGuesserInterface and the DataTypeValueToStringConverterInterface for further information.","title":"DataTypeInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html","text":"DataTypeValueToStringConverterInterface This interface is used to convert a value supplied by Magento to a string rendered in a grid cell. Overview Whenever you need to render some data type in grids and you don\u2019t want to use a custom template for that purpose, you can choose to implement this interface instead. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; interface DataTypeValueToStringConverterInterface { const UNLIMITED_RECURSION = - 1 ; public function toString ( $value ) : ? string ; public function toHtmlRecursive ( $value , $maxRecursionDepth = self :: UNLIMITED_RECURSION ) : ? string ; } Hyva_Admin uses the column type code to determine the converter to use. The column type code to converter mapping happens in the adminhtml di.xml . Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration, mapping column types to DataTypeValueToStringConverter : < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > < item name = \"price\" xsi:type = \"string\" > HyvaAdminModelDataTypePriceDataType </ item > ... </ argument > </ arguments > </ type > The array keys are the column data type codes, the values are the converter class names. A column type code might be automatically determined by a DataTypeGuesser , or it could be set explicitly in the grid configuration XML: < column name = \"price\" type = \"price\" /> When a cell is rendered, the method toString is used by default. Only if the column property renderAsUnsecureHtml=\"true\" is set for a column, the method toHtmlRecursive is used to stringify a value. Interface Methods toString($value): ?string The method takes a value and - if it matches the type supported by the converter - returns a string representation. If the type doesn\u2019t match for some reason, the converter should return null. An appropriate exception will be thrown elsewhere. The returned string should be a plain text representation and not handle HTML related logic. For example, an image property might be rendered as an image URL, rather than an <img> HTML element. Example: public function toString($value): ?string { return $this->canProcess($value) ? $this->dateTimeFormatter->formatObject(newDateTimeImmutable($value)) : null; } toHtmlRecursive($value, $maxRecursionDepth = -1): ?string This method is used to convert a supported value to a HTML representation. If a recursion doesn\u2019t make sense for a given value, it\u2019s okay to just return a string without recursing. The only data type where recursion is currently used is array . In many cases the string and the HTML representation of a value are the same. In such cases toHtmlRecursive can directly delegate to toString . Example: public function toHtmlRecursive( $value, $maxRecursionDepth = self::UNLIMITED_RECURSION ): ?string { return $this->canProcess($value) ? sprintf('<img src=\"%s\"/>', $this->getImageUrl($value)) : null; }","title":"DataTypeValueToStringConverterInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html#datatypevaluetostringconverterinterface","text":"This interface is used to convert a value supplied by Magento to a string rendered in a grid cell.","title":"DataTypeValueToStringConverterInterface"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html#overview","text":"Whenever you need to render some data type in grids and you don\u2019t want to use a custom template for that purpose, you can choose to implement this interface instead. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; interface DataTypeValueToStringConverterInterface { const UNLIMITED_RECURSION = - 1 ; public function toString ( $value ) : ? string ; public function toHtmlRecursive ( $value , $maxRecursionDepth = self :: UNLIMITED_RECURSION ) : ? string ; } Hyva_Admin uses the column type code to determine the converter to use. The column type code to converter mapping happens in the adminhtml di.xml . Excerpt of the Hyva_Admin etc/adminhtml/di.xml configuration, mapping column types to DataTypeValueToStringConverter : < type name = \"HyvaAdminModelDataTypeDataTypeFacade\" > < arguments > < argument name = \"dataTypeClassMap\" xsi:type = \"array\" > < item name = \"datetime\" xsi:type = \"string\" > HyvaAdminModelDataTypeDateTimeDataType </ item > < item name = \"price\" xsi:type = \"string\" > HyvaAdminModelDataTypePriceDataType </ item > ... </ argument > </ arguments > </ type > The array keys are the column data type codes, the values are the converter class names. A column type code might be automatically determined by a DataTypeGuesser , or it could be set explicitly in the grid configuration XML: < column name = \"price\" type = \"price\" /> When a cell is rendered, the method toString is used by default. Only if the column property renderAsUnsecureHtml=\"true\" is set for a column, the method toHtmlRecursive is used to stringify a value.","title":"Overview"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html#interface-methods","text":"","title":"Interface Methods"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html#tostringvalue-string","text":"The method takes a value and - if it matches the type supported by the converter - returns a string representation. If the type doesn\u2019t match for some reason, the converter should return null. An appropriate exception will be thrown elsewhere. The returned string should be a plain text representation and not handle HTML related logic. For example, an image property might be rendered as an image URL, rather than an <img> HTML element. Example: public function toString($value): ?string { return $this->canProcess($value) ? $this->dateTimeFormatter->formatObject(newDateTimeImmutable($value)) : null; }","title":"toString($value): ?string"},{"location":"api-reference/php-classes-and-interfaces/datatypevaluetostringconverterinterface.html#tohtmlrecursivevalue-maxrecursiondepth-1-string","text":"This method is used to convert a supported value to a HTML representation. If a recursion doesn\u2019t make sense for a given value, it\u2019s okay to just return a string without recursing. The only data type where recursion is currently used is array . In many cases the string and the HTML representation of a value are the same. In such cases toHtmlRecursive can directly delegate to toString . Example: public function toHtmlRecursive( $value, $maxRecursionDepth = self::UNLIMITED_RECURSION ): ?string { return $this->canProcess($value) ? sprintf('<img src=\"%s\"/>', $this->getImageUrl($value)) : null; }","title":"toHtmlRecursive($value, $maxRecursionDepth = -1): ?string"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html","text":"Grid AbstractExportType HyvaAdminModelGridExportTypeAbstractExportType is the base class for all grid export format implementations. At the time of writing, there are three built in export types: CSV - HyvaAdminModelGridExportTypeCsv XML - HyvaAdminModelGridExportTypeXml XLSX - HyvaAdminModelGridExportTypeXlsx Custom export types can be created by extending the AbstractExportType and setting the class attribute on the grid XML export configuration. Alternatively, the mapping from export type code to class can be extended via di.xml like the default types. < type name = \"HyvaAdminModelGridExportGridExportTypeLocator\" > < arguments > < argument name = \"gridExportTypes\" xsi:type = \"array\" > < item name = \"csv\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeCsv </ item > < item name = \"xml\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeXml </ item > < item name = \"xlsx\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeXlsx </ item > </ argument > </ arguments > </ type > In this case no class attribute needs to be specified in the grid export configuration. Abstract methods: public function createFileToDownload(): void When called this method should create the file to be exported on the filesystem with the export data. The file will automatically be deleted after the contents are sent to the browser. The CSV export class can serve as a simple implementation reference: public function createFileToDownload(): void { $file = $this->getFileName(); $directory = $this->filesystem->getDirectoryWrite($this->getExportDir()); $stream = $directory->openFile($file, 'w+'); $stream->lock(); $stream->writeCsv($this->getHeaderData()); foreach ($this->iterateGrid() as $row) { $stream->writeCsv(map(function (CellInterface $cell): string { return $cell->getTextValue(); }, $row->getCells())); } $stream->unlock(); $stream->close(); } Parent class methods: There are a number of methods provided by the abstract parent class that are helpful during the export file generation. These methods are generally not intended to be overridden in the export implementation even though they are not declared as final. public function getFileName(): string This method returns the name to use for the export file within the Magento var/ directory. If a file name is configured in the grid export configuration, that will be used. Otherwise the grid name with the export type code as a file name suffix will be used as a default. public function getContentType(): string This method is used by the download controller to determine the HTTP response content type header value. The content type defaults to application/octet-stream , which triggers a file save dialog in browsers. Usually the content type does not need to be changed for export type implementations. public function getExportDir(): string This method returns the code for the Magento directory in which the file name returned by getFileName() return value is created. It defaults to the Magento var/ directory, which should be fine for almost all cases. (See MagentoFrameworkAppFilesystemDirectoryList for a list of all Magento directory codes. protected function getGrid(): HyvaGridExportInterface This method can be used to retrieve the instance of the grid that is being exported. For example, this could potentially be useful to get the grid name $this->getGrid()->getGridName() . protected function getHeaderData(): array This method can be used by export implementations to fetch the column names of the grid as an array. protected function iterateGrid():Iterator This method returns an iterator over all grid rows. The grid data will be loaded in batches of 200 rows at a time as to not exhaust memory.","title":"Grid AbstractExportType"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#grid-abstractexporttype","text":"HyvaAdminModelGridExportTypeAbstractExportType is the base class for all grid export format implementations. At the time of writing, there are three built in export types: CSV - HyvaAdminModelGridExportTypeCsv XML - HyvaAdminModelGridExportTypeXml XLSX - HyvaAdminModelGridExportTypeXlsx Custom export types can be created by extending the AbstractExportType and setting the class attribute on the grid XML export configuration. Alternatively, the mapping from export type code to class can be extended via di.xml like the default types. < type name = \"HyvaAdminModelGridExportGridExportTypeLocator\" > < arguments > < argument name = \"gridExportTypes\" xsi:type = \"array\" > < item name = \"csv\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeCsv </ item > < item name = \"xml\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeXml </ item > < item name = \"xlsx\" xsi:type = \"string\" > HyvaAdminModelGridExportTypeXlsx </ item > </ argument > </ arguments > </ type > In this case no class attribute needs to be specified in the grid export configuration.","title":"Grid AbstractExportType"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#abstract-methods","text":"","title":"Abstract methods:"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#public-function-createfiletodownload-void","text":"When called this method should create the file to be exported on the filesystem with the export data. The file will automatically be deleted after the contents are sent to the browser. The CSV export class can serve as a simple implementation reference: public function createFileToDownload(): void { $file = $this->getFileName(); $directory = $this->filesystem->getDirectoryWrite($this->getExportDir()); $stream = $directory->openFile($file, 'w+'); $stream->lock(); $stream->writeCsv($this->getHeaderData()); foreach ($this->iterateGrid() as $row) { $stream->writeCsv(map(function (CellInterface $cell): string { return $cell->getTextValue(); }, $row->getCells())); } $stream->unlock(); $stream->close(); }","title":"public function createFileToDownload(): void"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#parent-class-methods","text":"There are a number of methods provided by the abstract parent class that are helpful during the export file generation. These methods are generally not intended to be overridden in the export implementation even though they are not declared as final.","title":"Parent class methods:"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#public-function-getfilename-string","text":"This method returns the name to use for the export file within the Magento var/ directory. If a file name is configured in the grid export configuration, that will be used. Otherwise the grid name with the export type code as a file name suffix will be used as a default.","title":"public function getFileName(): string"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#public-function-getcontenttype-string","text":"This method is used by the download controller to determine the HTTP response content type header value. The content type defaults to application/octet-stream , which triggers a file save dialog in browsers. Usually the content type does not need to be changed for export type implementations.","title":"public function getContentType(): string"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#public-function-getexportdir-string","text":"This method returns the code for the Magento directory in which the file name returned by getFileName() return value is created. It defaults to the Magento var/ directory, which should be fine for almost all cases. (See MagentoFrameworkAppFilesystemDirectoryList for a list of all Magento directory codes.","title":"public function getExportDir(): string"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#protected-function-getgrid-hyvagridexportinterface","text":"This method can be used to retrieve the instance of the grid that is being exported. For example, this could potentially be useful to get the grid name $this->getGrid()->getGridName() .","title":"protected function getGrid(): HyvaGridExportInterface"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#protected-function-getheaderdata-array","text":"This method can be used by export implementations to fetch the column names of the grid as an array.","title":"protected function getHeaderData(): array"},{"location":"api-reference/php-classes-and-interfaces/grid-abstractexporttype.html#protected-function-iterategriditerator","text":"This method returns an iterator over all grid rows. The grid data will be loaded in batches of 200 rows at a time as to not exhaust memory.","title":"protected function iterateGrid():Iterator"},{"location":"api-reference/php-classes-and-interfaces/hyvagridarrayproviderinterface.html","text":"HyvaGridArrayProviderInterface The HyvaGridArrayProviderInterface is used for creating simple grid data providers. Overview Often creating a repository is overkill when a simple list of things should be displayed in the admin. This is where the array grid providers shine. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; /** * Implement this interface and specify that class as an array source type for a hyva grid. * Return an array with one sub-array for each row of the grid. */ interface HyvaGridArrayProviderInterface { /** * @return array[] */ public function getHyvaGridData () : array ; } A array provider implementations are then configured as source of a grid in the grid XML: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > It is super simple to create array grid data providers. There are some helpful methods to covert things into arrays in the Magento framework, for example MagentoFrameworkReflectionDataObjectProcessor::buildOutputDataArray . They can be useful sometimes, but of course anything can be used as long as the interface contract is fulfilled. Interface Methods getHyvaGridData(): array The interface only has a single method. It returns an array of arrays. Each sub-array, or record, is a row in the grid. Here is a simplified example to clarify the return array structure: public function getHyvaGridData(): array { return [ ['col-A' => 'the first value', 'col-B' => 'another value'], ['col-A' => 'more data', 'col-B' => 'even more data'], ... ]; } The array keys of the first record are used to determine the columns for the grid. Example grid array provider that lists all files in the Magento var/log/ directory: <?php declare ( strict_types = 1 ); namespace HyvaAdminTestModel ; use HyvaAdminApiHyvaGridArrayProviderInterface ; use MagentoFrameworkAppFilesystemDirectoryList ; use MagentoFrameworkFilesystemIoFileFactory ; class LogFileListProvider implements HyvaGridArrayProviderInterface { private DirectoryList $directoryList ; private FileFactory $fileFactory ; public function __construct ( DirectoryList $directoryList , FileFactory $fileFactory ) { $this -> directoryList = $directoryList ; $this -> fileFactory = $fileFactory ; } public function getHyvaGridData () : array { $file = $this -> fileFactory -> create (); $file -> cd ( $this -> directoryList -> getPath ( DirectoryList :: LOG )); return $file -> ls (); } }","title":"HyvaGridArrayProviderInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridarrayproviderinterface.html#hyvagridarrayproviderinterface","text":"The HyvaGridArrayProviderInterface is used for creating simple grid data providers.","title":"HyvaGridArrayProviderInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridarrayproviderinterface.html#overview","text":"Often creating a repository is overkill when a simple list of things should be displayed in the admin. This is where the array grid providers shine. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; /** * Implement this interface and specify that class as an array source type for a hyva grid. * Return an array with one sub-array for each row of the grid. */ interface HyvaGridArrayProviderInterface { /** * @return array[] */ public function getHyvaGridData () : array ; } A array provider implementations are then configured as source of a grid in the grid XML: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > It is super simple to create array grid data providers. There are some helpful methods to covert things into arrays in the Magento framework, for example MagentoFrameworkReflectionDataObjectProcessor::buildOutputDataArray . They can be useful sometimes, but of course anything can be used as long as the interface contract is fulfilled.","title":"Overview"},{"location":"api-reference/php-classes-and-interfaces/hyvagridarrayproviderinterface.html#interface-methods","text":"","title":"Interface Methods"},{"location":"api-reference/php-classes-and-interfaces/hyvagridarrayproviderinterface.html#gethyvagriddata-array","text":"The interface only has a single method. It returns an array of arrays. Each sub-array, or record, is a row in the grid. Here is a simplified example to clarify the return array structure: public function getHyvaGridData(): array { return [ ['col-A' => 'the first value', 'col-B' => 'another value'], ['col-A' => 'more data', 'col-B' => 'even more data'], ... ]; } The array keys of the first record are used to determine the columns for the grid. Example grid array provider that lists all files in the Magento var/log/ directory: <?php declare ( strict_types = 1 ); namespace HyvaAdminTestModel ; use HyvaAdminApiHyvaGridArrayProviderInterface ; use MagentoFrameworkAppFilesystemDirectoryList ; use MagentoFrameworkFilesystemIoFileFactory ; class LogFileListProvider implements HyvaGridArrayProviderInterface { private DirectoryList $directoryList ; private FileFactory $fileFactory ; public function __construct ( DirectoryList $directoryList , FileFactory $fileFactory ) { $this -> directoryList = $directoryList ; $this -> fileFactory = $fileFactory ; } public function getHyvaGridData () : array { $file = $this -> fileFactory -> create (); $file -> cd ( $this -> directoryList -> getPath ( DirectoryList :: LOG )); return $file -> ls (); } }","title":"getHyvaGridData(): array"},{"location":"api-reference/php-classes-and-interfaces/hyvagridcollectionprocessorinterface.html","text":"HyvaGridCollectionProcessorInterface This interface extends the regular HyvaGridSourceProcessorInterface . It provides an afterInitSelect callback that is only applicable to collection grid sources. public function afterInitSelect(MagentoFrameworkDataCollectionAbstractDb $source, string $gridName ): void; This callback is triggered every time the collection grid source is instantiated, before the search criteria is applied. It is intended to allow joining additional fields that will then be available as grid columns. These fields then will be available as grid columns. To use it, configure a grid source processor as usual and implement the interface in addition to extending the processor from HyvaAdminModelGridSourceAbstractGridSourceProcessor . Example: This is an example collection grid source processor as declared in an integration test: new class() extends AbstractGridSourceProcessor implements HyvaGridCollectionProcessorInterface { public function afterInitSelect(AbstractDbCollection $source, string $gridName): void { $select = $source->getSelect(); // select expression $select->columns(['foo' => newZend_Db_Expr('foo')]); // select field from joined table $source->getSelect()->joinLeft( 'catalog_category_product', 'e.entity_id = catalog_category_product.product_id', ['test_field' => 'catalog_category_product.entity_id'] ); } };","title":"HyvaGridCollectionProcessorInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridcollectionprocessorinterface.html#hyvagridcollectionprocessorinterface","text":"This interface extends the regular HyvaGridSourceProcessorInterface . It provides an afterInitSelect callback that is only applicable to collection grid sources. public function afterInitSelect(MagentoFrameworkDataCollectionAbstractDb $source, string $gridName ): void; This callback is triggered every time the collection grid source is instantiated, before the search criteria is applied. It is intended to allow joining additional fields that will then be available as grid columns. These fields then will be available as grid columns. To use it, configure a grid source processor as usual and implement the interface in addition to extending the processor from HyvaAdminModelGridSourceAbstractGridSourceProcessor .","title":"HyvaGridCollectionProcessorInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridcollectionprocessorinterface.html#example","text":"This is an example collection grid source processor as declared in an integration test: new class() extends AbstractGridSourceProcessor implements HyvaGridCollectionProcessorInterface { public function afterInitSelect(AbstractDbCollection $source, string $gridName): void { $select = $source->getSelect(); // select expression $select->columns(['foo' => newZend_Db_Expr('foo')]); // select field from joined table $source->getSelect()->joinLeft( 'catalog_category_product', 'e.entity_id = catalog_category_product.product_id', ['test_field' => 'catalog_category_product.entity_id'] ); } };","title":"Example:"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html","text":"HyvaGridFilterTypeInterface Filter types are responsible for supplying the filter renderer block and for applying the posted values to a SearchCriteria instance. Overview There are a number of filter types in Hyva_Admin out of the box: boolean date-range select text value-range Chances are these are all you will ever need. But if there is a column data type that doesn\u2019t match any of these, then you can implement a custom filter type by implementing this interface. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; use HyvaAdminViewModelHyvaGridColumnDefinitionInterface ; use HyvaAdminViewModelHyvaGridGridFilterInterface ; use MagentoFrameworkApiSearchCriteriaBuilder ; use MagentoFrameworkViewElementTemplate ; interface HyvaGridFilterTypeInterface { public function getRenderer ( ColumnDefinitionInterface $columnDefinition ) : Template ; public function apply ( SearchCriteriaBuilder $searchCriteriaBuilder , GridFilterInterface $gridFilter , $filterValue ) : void ; } The custom filter type then is used by specifying it in the grid configuration: < navigation > < filters > < filter column = \"some_column\" filterType = \"MyCustomGridFilterType\" /> </ filters > </ navigation > Interface Methods getRenderer(ColumnDefinitionInterface $columnDefinition): Template This method returns the template block instance that will be used to render the filter above the column. The HyvaAdminViewModelHyvaGridGridFilterInterface instance that is currently being rendered will automatically be set on the template block in the variable $filter before the blocks toHtml() method is called. Example: public function getRenderer ( ColumnDefinitionInterface $columnDefinition ) : Template { /** @var Template $templateBlock */ $templateBlock = $this -> layout -> createBlock ( Template :: class ); $templateBlock -> setTemplate ( 'Hyva_Admin::grid/filter/date-range.phtml' ); return $templateBlock ; } If a template is specified in the filter configuration XML in addition to a custom filter type, then the template will be set on the the renderer, overwriting any template that might already be set in the getRenderer method. apply($searchCriteriaBuilder, $gridFilter, $filterValue): void The purpose of the apply method is to set filter values that where specified in the admin UI on a SearchCriteriaBuilder instance. The full method signature is too long to fit into the title above, so here it is again in all it\u2019s glory: public function apply( SearchCriteriaBuilder $searchCriteriaBuilder, GridFilterInterface $gridFilter, $filterValue ): void; The first argument is the $searchCriteriaBuilder instance that is meant to receive the filter settings in the apply method. The second argument is the GridFilterInterface instance containing the column definition. The posted filter value is passed as the third argument, $filterValue . Here is an example taken from the value-range filter type: public function apply( SearchCriteriaBuilder $searchCriteriaBuilder, GridFilterInterface $gridFilter, $filterValue ): void { $key = $gridFilter->getColumnDefinition()->getKey(); if ($this->isValue($from = $filterValue['from'] ?? '')) { $searchCriteriaBuilder->addFilter($key, $from, 'gteq'); } if ($this->isValue($to = $filterValue['to'] ?? '')) { $searchCriteriaBuilder->addFilter($key, $to, 'lteq'); } } private function isValue($value): bool { return isset($value) && '' !== $value; }","title":"HyvaGridFilterTypeInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html#hyvagridfiltertypeinterface","text":"Filter types are responsible for supplying the filter renderer block and for applying the posted values to a SearchCriteria instance.","title":"HyvaGridFilterTypeInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html#overview","text":"There are a number of filter types in Hyva_Admin out of the box: boolean date-range select text value-range Chances are these are all you will ever need. But if there is a column data type that doesn\u2019t match any of these, then you can implement a custom filter type by implementing this interface. <?php declare ( strict_types = 1 ); namespace HyvaAdminApi ; use HyvaAdminViewModelHyvaGridColumnDefinitionInterface ; use HyvaAdminViewModelHyvaGridGridFilterInterface ; use MagentoFrameworkApiSearchCriteriaBuilder ; use MagentoFrameworkViewElementTemplate ; interface HyvaGridFilterTypeInterface { public function getRenderer ( ColumnDefinitionInterface $columnDefinition ) : Template ; public function apply ( SearchCriteriaBuilder $searchCriteriaBuilder , GridFilterInterface $gridFilter , $filterValue ) : void ; } The custom filter type then is used by specifying it in the grid configuration: < navigation > < filters > < filter column = \"some_column\" filterType = \"MyCustomGridFilterType\" /> </ filters > </ navigation >","title":"Overview"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html#interface-methods","text":"","title":"Interface Methods"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html#getrenderercolumndefinitioninterface-columndefinition-template","text":"This method returns the template block instance that will be used to render the filter above the column. The HyvaAdminViewModelHyvaGridGridFilterInterface instance that is currently being rendered will automatically be set on the template block in the variable $filter before the blocks toHtml() method is called. Example: public function getRenderer ( ColumnDefinitionInterface $columnDefinition ) : Template { /** @var Template $templateBlock */ $templateBlock = $this -> layout -> createBlock ( Template :: class ); $templateBlock -> setTemplate ( 'Hyva_Admin::grid/filter/date-range.phtml' ); return $templateBlock ; } If a template is specified in the filter configuration XML in addition to a custom filter type, then the template will be set on the the renderer, overwriting any template that might already be set in the getRenderer method.","title":"getRenderer(ColumnDefinitionInterface $columnDefinition): Template"},{"location":"api-reference/php-classes-and-interfaces/hyvagridfiltertypeinterface.html#applysearchcriteriabuilder-gridfilter-filtervalue-void","text":"The purpose of the apply method is to set filter values that where specified in the admin UI on a SearchCriteriaBuilder instance. The full method signature is too long to fit into the title above, so here it is again in all it\u2019s glory: public function apply( SearchCriteriaBuilder $searchCriteriaBuilder, GridFilterInterface $gridFilter, $filterValue ): void; The first argument is the $searchCriteriaBuilder instance that is meant to receive the filter settings in the apply method. The second argument is the GridFilterInterface instance containing the column definition. The posted filter value is passed as the third argument, $filterValue . Here is an example taken from the value-range filter type: public function apply( SearchCriteriaBuilder $searchCriteriaBuilder, GridFilterInterface $gridFilter, $filterValue ): void { $key = $gridFilter->getColumnDefinition()->getKey(); if ($this->isValue($from = $filterValue['from'] ?? '')) { $searchCriteriaBuilder->addFilter($key, $from, 'gteq'); } if ($this->isValue($to = $filterValue['to'] ?? '')) { $searchCriteriaBuilder->addFilter($key, $to, 'lteq'); } } private function isValue($value): bool { return isset($value) && '' !== $value; }","title":"apply($searchCriteriaBuilder, $gridFilter, $filterValue): void"},{"location":"api-reference/php-classes-and-interfaces/hyvagridsourceprocessorinterface.html","text":"HyvaGridSourceProcessorInterface This interface is implemented by all grid source processors. Grid source processors are an advanced tool that is only rarely needed. /** * Implement this interface in your module and configure it on a grid: * * <grid> * <source> * ... other source config ... * <processors> * <processor class=\"YourModuleHyvaGridProcessorMyGridQueryProcessor\"/> * </processors> * </source> * </grid> */ interface HyvaGridSourceProcessorInterface { /** * Provides the ability to mutate the grid $source before the grid data is loaded. * * The search criteria will already have been applied (if applicable for a given source type). * Do not mutate $searchCriteria since that will cause multiple loads (it's signature changes, * seeHyvaAdminModelGridSourceSearchCriteriaIdentity). * * The type of $source is grid configuration dependent (it might be a Select instance, or a * collection, or a repository, ...). * * @param mixed $source * @param SearchCriteriaInterface $searchCriteria * @param string $gridName */ public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void; /** * Provides the ability to change the raw grid result after it is loaded. * * The method must return the new result or null. The $result type depends on the grid configuration. * If null is returned, the result value from before afterLoad is used. * * Do not mutate $searchCriteria since that will cause multiple loads (because )it's signature change, * see note on beforeLoad above). * * @param mixed $rawResult * @param SearchCriteriaInterface $searchCriteria * @param string $gridName * @return mixed */ public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName); } If you require only one of the two methods, consider extending your processor from the AbstractGridSourceProcessor , which provides a null-op implementation of the interface, and override only the method you need.","title":"HyvaGridSourceProcessorInterface"},{"location":"api-reference/php-classes-and-interfaces/hyvagridsourceprocessorinterface.html#hyvagridsourceprocessorinterface","text":"This interface is implemented by all grid source processors. Grid source processors are an advanced tool that is only rarely needed. /** * Implement this interface in your module and configure it on a grid: * * <grid> * <source> * ... other source config ... * <processors> * <processor class=\"YourModuleHyvaGridProcessorMyGridQueryProcessor\"/> * </processors> * </source> * </grid> */ interface HyvaGridSourceProcessorInterface { /** * Provides the ability to mutate the grid $source before the grid data is loaded. * * The search criteria will already have been applied (if applicable for a given source type). * Do not mutate $searchCriteria since that will cause multiple loads (it's signature changes, * seeHyvaAdminModelGridSourceSearchCriteriaIdentity). * * The type of $source is grid configuration dependent (it might be a Select instance, or a * collection, or a repository, ...). * * @param mixed $source * @param SearchCriteriaInterface $searchCriteria * @param string $gridName */ public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void; /** * Provides the ability to change the raw grid result after it is loaded. * * The method must return the new result or null. The $result type depends on the grid configuration. * If null is returned, the result value from before afterLoad is used. * * Do not mutate $searchCriteria since that will cause multiple loads (because )it's signature change, * see note on beforeLoad above). * * @param mixed $rawResult * @param SearchCriteriaInterface $searchCriteria * @param string $gridName * @return mixed */ public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName); } If you require only one of the two methods, consider extending your processor from the AbstractGridSourceProcessor , which provides a null-op implementation of the interface, and override only the method you need.","title":"HyvaGridSourceProcessorInterface"},{"location":"guides/installation.html","text":"Installation Requirements Magento 2.4.0 CE (the $escaper variable needs to be declared in templates) PHP >= 7.3 Access to the Hyv\u00e4 repository Getting Started The module can be installed via composer by adding the repository as a source and then requiring it: composer require hyva-themes/module-magento2-admin If you want to just play around to get a feel for Hyva_Admin grids, you can install a test module that declares an example grid, too: composer require hyva-themes/module-magento2-admin-test Note: development of the module uses PHP 7.4, but the releases are based on a branch that is automatically backported, thanks to rector. Stability The API will remain stable, unless some real flaw is discovered. New features will be added in a backward compatible manner.","title":"Installation"},{"location":"guides/installation.html#installation","text":"","title":"Installation"},{"location":"guides/installation.html#requirements","text":"Magento 2.4.0 CE (the $escaper variable needs to be declared in templates) PHP >= 7.3 Access to the Hyv\u00e4 repository","title":"Requirements"},{"location":"guides/installation.html#getting-started","text":"The module can be installed via composer by adding the repository as a source and then requiring it: composer require hyva-themes/module-magento2-admin If you want to just play around to get a feel for Hyva_Admin grids, you can install a test module that declares an example grid, too: composer require hyva-themes/module-magento2-admin-test Note: development of the module uses PHP 7.4, but the releases are based on a branch that is automatically backported, thanks to rector.","title":"Getting Started"},{"location":"guides/installation.html#stability","text":"The API will remain stable, unless some real flaw is discovered. New features will be added in a backward compatible manner.","title":"Stability"},{"location":"guides/design-docs/index.html","text":"5. Deep Docs This section contains design documents and more detailed information, mostly useful for building custom column types and filters. This information is not required knowledge in order to use Hyv\u00e4 Admin Grids.","title":"Overview"},{"location":"guides/design-docs/index.html#5-deep-docs","text":"This section contains design documents and more detailed information, mostly useful for building custom column types and filters. This information is not required knowledge in order to use Hyv\u00e4 Admin Grids.","title":"5. Deep Docs"},{"location":"guides/design-docs/design-principles.html","text":"Design Principles The purpose of Hyva_Admin is to empower developers to get work done efficiently and allow them to enjoy their work. The module seeks to fulfill this purpose by using the following principles to guide development: Use defaults that allow accomplishing tasks with as little code as possible (good enough for 80% of all use cases). Create a system that leverages IDE/editor support as much as possible. Use existing, well understood technology like Layout XML, Blocks, XML merging, .phtml templates. Add extensibility for use cases that are understood without compromising usability (do not requires developers to create lots of code for simple use cases). Long Term Backward Compatibility: once an API aspect is released as stable it never changes. Only new features are added in a backward compatible manner. Make using Hyva_Admin fun.","title":"Design Principles"},{"location":"guides/design-docs/design-principles.html#design-principles","text":"The purpose of Hyva_Admin is to empower developers to get work done efficiently and allow them to enjoy their work. The module seeks to fulfill this purpose by using the following principles to guide development: Use defaults that allow accomplishing tasks with as little code as possible (good enough for 80% of all use cases). Create a system that leverages IDE/editor support as much as possible. Use existing, well understood technology like Layout XML, Blocks, XML merging, .phtml templates. Add extensibility for use cases that are understood without compromising usability (do not requires developers to create lots of code for simple use cases). Long Term Backward Compatibility: once an API aspect is released as stable it never changes. Only new features are added in a backward compatible manner. Make using Hyva_Admin fun.","title":"Design Principles"},{"location":"guides/design-docs/filtering-extension-attribute-columns.html","text":"Filtering Extension Attribute Columns By default no columns have filters. To enable filtering for a column, add a grid > navigation > filters > filter element to the grid definition. The type of filter depends on the column type. More information on this can be found in the filter node documentation in the Grid XML API reference. Here I want to note some thoughts on applying custom filter types, for example to allow filtering columns containing extension attributes. The repository grid provider type dispatches an event hyva_grid_source_prefetch_ + grid-name whenever grid data is about to be loaded. (Non-alphanumeric characters in the grid name like - are turned into underscores so the event name is valid in Magento events.xml files). This is the code in the RepositoryGridSourceType class that dispatches the event: private function dispatchEvent( string $gridName, string $recordType, SearchCriteriaInterface $searchCriteria ): SearchCriteriaInterface { $eventName = 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName): $container = new SearchCriteriaEventContainer($searchCriteria); $this->eventManager->dispatch($eventName, [ 'search_criteria_container' => $container, 'grid_name' => $gridName, 'record_type' => $recordType ]); return $container->getSearchCriteria(); } Event observers can modify or replace the search criteria, or they can also remember the search criteria values and apply the appropriate values when an extension attribute is loaded after the main record data. This event may also be used to do other modifications to the SearchCriteria , for example mapping attribute codes to internal column names.","title":"Filtering Extension Attribute Columns"},{"location":"guides/design-docs/filtering-extension-attribute-columns.html#filtering-extension-attribute-columns","text":"By default no columns have filters. To enable filtering for a column, add a grid > navigation > filters > filter element to the grid definition. The type of filter depends on the column type. More information on this can be found in the filter node documentation in the Grid XML API reference. Here I want to note some thoughts on applying custom filter types, for example to allow filtering columns containing extension attributes. The repository grid provider type dispatches an event hyva_grid_source_prefetch_ + grid-name whenever grid data is about to be loaded. (Non-alphanumeric characters in the grid name like - are turned into underscores so the event name is valid in Magento events.xml files). This is the code in the RepositoryGridSourceType class that dispatches the event: private function dispatchEvent( string $gridName, string $recordType, SearchCriteriaInterface $searchCriteria ): SearchCriteriaInterface { $eventName = 'hyva_grid_source_prefetch_' . $this->getGridNameEventSuffix($gridName): $container = new SearchCriteriaEventContainer($searchCriteria); $this->eventManager->dispatch($eventName, [ 'search_criteria_container' => $container, 'grid_name' => $gridName, 'record_type' => $recordType ]); return $container->getSearchCriteria(); } Event observers can modify or replace the search criteria, or they can also remember the search criteria values and apply the appropriate values when an extension attribute is loaded after the main record data. This event may also be used to do other modifications to the SearchCriteria , for example mapping attribute codes to internal column names.","title":"Filtering Extension Attribute Columns"},{"location":"guides/design-docs/hyva-admin-forms-wip.html","text":"Hyva Admin Forms (WIP) At the moment this document is just a brain dump of my thoughts on this topic to lead into some kind of collaboration. This page has been replaced by two github issues: More up-to-date information can be found in this github issue: https://github.com/hyva-themes/magento2-hyva-admin/issues/27 The current state of the implementation is recorded here: https://github.com/hyva-themes/magento2-hyva-admin/issues/36","title":"Hyva Admin Forms (WIP)"},{"location":"guides/design-docs/hyva-admin-forms-wip.html#hyva-admin-forms-wip","text":"At the moment this document is just a brain dump of my thoughts on this topic to lead into some kind of collaboration. This page has been replaced by two github issues: More up-to-date information can be found in this github issue: https://github.com/hyva-themes/magento2-hyva-admin/issues/27 The current state of the implementation is recorded here: https://github.com/hyva-themes/magento2-hyva-admin/issues/36","title":"Hyva Admin Forms (WIP)"},{"location":"guides/design-docs/rationale.html","text":"Rationale When using the Magento 2 UI Components to create admin grids and forms, I always felt like I was dying a bit inside. From my point of view it's an awful system for a number of reasons that I don't want to go into more details about now. Alternative store fronts that do not use UI components (PWA Studio, Hyv\u00e4 Themes) are great for frontend developers, but (un?)fortunately I do mostly backend work. The UI interfaces I create are mainly for store owners and admins. I desire a way to do my job (which includes building grids and forms) that doesn't feel like I have to fight the framework. Instead, I want to feel empowered and get work done quickly and efficiently. After years of bitching about Magento, I was very impressed by the work Willem Wigman did with the Hyv\u00e4 frontend theme. He inspired me to stop complaining and also take matters into my own hands, and finally build the tools I desire. Hence, Hyva_Admin.","title":"Rationale"},{"location":"guides/design-docs/rationale.html#rationale","text":"When using the Magento 2 UI Components to create admin grids and forms, I always felt like I was dying a bit inside. From my point of view it's an awful system for a number of reasons that I don't want to go into more details about now. Alternative store fronts that do not use UI components (PWA Studio, Hyv\u00e4 Themes) are great for frontend developers, but (un?)fortunately I do mostly backend work. The UI interfaces I create are mainly for store owners and admins. I desire a way to do my job (which includes building grids and forms) that doesn't feel like I have to fight the framework. Instead, I want to feel empowered and get work done quickly and efficiently. After years of bitching about Magento, I was very impressed by the work Willem Wigman did with the Hyv\u00e4 frontend theme. He inspired me to stop complaining and also take matters into my own hands, and finally build the tools I desire. Hence, Hyva_Admin.","title":"Rationale"},{"location":"guides/design-docs/sorting-columns.html","text":"Sorting Columns As a default, all columns are sortable when possible. If you don\u2019t want a column to be sortable, add a sortable=\"false\" attribute to the column configuration. The question is, when can a column not be sorted ? It depends on the grid data provider. For array providers, all columns are sortable, because the sorting is applied to the grid data by the Hyva_Admin module itself. For Repository grid data providers (and in future Collection and Query), the sorting is applied by the repository itself, when the search criteria is mapped to the underlying ORM collection. For columns that are loaded loaded as part of the main query, that works very well. However, if a column value is loaded in a separate query, the sorting can\u2019t be applied. For this reason, Hyva_Admin sets the sortable property on columns to false automatically in the following cases: For columns containing an extension attribute value For product category IDs For the product media gallery More special cases might exist that I haven\u2019t encountered yet. In such cases you will see an exception when trying to sort by a non-existent column, or maybe sorting will simply not do anything, depending on the source repository implementation. If you want to enable sorting by such fields, you can override that default sortable value in the column XML definition by setting sortable=\"true\" , and implement a plugin to apply the sorting after the data has been loaded by the repository.","title":"Sorting Columns"},{"location":"guides/design-docs/sorting-columns.html#sorting-columns","text":"As a default, all columns are sortable when possible. If you don\u2019t want a column to be sortable, add a sortable=\"false\" attribute to the column configuration. The question is, when can a column not be sorted ? It depends on the grid data provider. For array providers, all columns are sortable, because the sorting is applied to the grid data by the Hyva_Admin module itself. For Repository grid data providers (and in future Collection and Query), the sorting is applied by the repository itself, when the search criteria is mapped to the underlying ORM collection. For columns that are loaded loaded as part of the main query, that works very well. However, if a column value is loaded in a separate query, the sorting can\u2019t be applied. For this reason, Hyva_Admin sets the sortable property on columns to false automatically in the following cases: For columns containing an extension attribute value For product category IDs For the product media gallery More special cases might exist that I haven\u2019t encountered yet. In such cases you will see an exception when trying to sort by a non-existent column, or maybe sorting will simply not do anything, depending on the source repository implementation. If you want to enable sorting by such fields, you can override that default sortable value in the column XML definition by setting sortable=\"true\" , and implement a plugin to apply the sorting after the data has been loaded by the repository.","title":"Sorting Columns"},{"location":"guides/hyva-admin-grid-walkthrough/buttons.html","text":"Buttons Buttons that should be rendered above the grid can be declared as part of the navigation: < navigation > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" /> < button id = \"refresh\" label = \"Refresh Page\" onclick = \"window.location.reload(true)\" sortOrder = \"-1\" /> </ buttons > </ navigation > Buttons can use either an url or an onclick attribute to specify their effect. Please refer to the Grid XML API Reference for more information.","title":"Buttons"},{"location":"guides/hyva-admin-grid-walkthrough/buttons.html#buttons","text":"Buttons that should be rendered above the grid can be declared as part of the navigation: < navigation > < buttons > < button id = \"add\" label = \"Add\" url = \"*/*/add\" /> < button id = \"refresh\" label = \"Refresh Page\" onclick = \"window.location.reload(true)\" sortOrder = \"-1\" /> </ buttons > </ navigation > Buttons can use either an url or an onclick attribute to specify their effect. Please refer to the Grid XML API Reference for more information.","title":"Buttons"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-columns.html","text":"Configuring Columns Hyva_Admin tries to extract the available columns from the grid source. Without any configuration, all columns are shown in an order determined by the source type. In some cases this already will be good enough, but often you will need to tweak which columns are displayed, the ordering of columns or how column data is rendered. This is done in the <columns> grid XML section. To specify which columns to display, use the <columns><include/></columns> branch. For example, to display only id , sku and name columns , in that order, configure: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"name\" /> </ include > </ columns > Once include columns are configured, all other available columns are no longer displayed. To hide columns, use the <columns><exclude/><columns> branch. Say you would like to display all columns except the category_gear column, this configuration would do the trick: < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > There are many attributes that can be specified on include columns. They are (in alphabetical order): initiallyHidden label name renderAsUnsecureHtml rendererBlockName sortable sortOrder source template type For more information on the attributes, I suggest you inspect the auto-completion offered by your editor, or have a look at the Grid XML API reference (or read the schema XSD file).","title":"Configuring Columns"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-columns.html#configuring-columns","text":"Hyva_Admin tries to extract the available columns from the grid source. Without any configuration, all columns are shown in an order determined by the source type. In some cases this already will be good enough, but often you will need to tweak which columns are displayed, the ordering of columns or how column data is rendered. This is done in the <columns> grid XML section. To specify which columns to display, use the <columns><include/></columns> branch. For example, to display only id , sku and name columns , in that order, configure: < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"name\" /> </ include > </ columns > Once include columns are configured, all other available columns are no longer displayed. To hide columns, use the <columns><exclude/><columns> branch. Say you would like to display all columns except the category_gear column, this configuration would do the trick: < columns > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > There are many attributes that can be specified on include columns. They are (in alphabetical order): initiallyHidden label name renderAsUnsecureHtml rendererBlockName sortable sortOrder source template type For more information on the attributes, I suggest you inspect the auto-completion offered by your editor, or have a look at the Grid XML API reference (or read the schema XSD file).","title":"Configuring Columns"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-mass-actions.html","text":"Configuring Mass Actions Mass actions allow users to select multiple records on a grid and submit all selected IDs to a controller at once. The mass action can be selected with a select input above the grid. < massActions idColumn = \"id\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" /> </ massActions > When one or more mass actions are configured, a column with a checkbox is rendered on the left side of the grid for each row. For more details on mass actions and available attributes, please check out the massActions Grid XML api reference.","title":"Configuring Mass Actions"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-mass-actions.html#configuring-mass-actions","text":"Mass actions allow users to select multiple records on a grid and submit all selected IDs to a controller at once. The mass action can be selected with a select input above the grid. < massActions idColumn = \"id\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" /> </ massActions > When one or more mass actions are configured, a column with a checkbox is rendered on the left side of the grid for each row. For more details on mass actions and available attributes, please check out the massActions Grid XML api reference.","title":"Configuring Mass Actions"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-row-actions.html","text":"Configuring Row Actions Each row can have zero or more actions. Actions are configured in an <actions> element. < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Each action is rendered as a link in a special actions column on the right side of the grid. The actions column is only present if there is at least one action. The url format uses the Magento route syntax, where a * means the current route id or action path, depending on its position. To make grid rows clickable, an action can be assigned as the default action by setting the action id as the rowAction attribute on the columns element: < columns rowAction = \"edit\" > < include > ... </ include > </ columns > For more information on the available attributes please head over to the action element Grid XML API reference.","title":"Configuring Row Actions"},{"location":"guides/hyva-admin-grid-walkthrough/configuring-row-actions.html#configuring-row-actions","text":"Each row can have zero or more actions. Actions are configured in an <actions> element. < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > Each action is rendered as a link in a special actions column on the right side of the grid. The actions column is only present if there is at least one action. The url format uses the Magento route syntax, where a * means the current route id or action path, depending on its position. To make grid rows clickable, an action can be assigned as the default action by setting the action id as the rowAction attribute on the columns element: < columns rowAction = \"edit\" > < include > ... </ include > </ columns > For more information on the available attributes please head over to the action element Grid XML API reference.","title":"Configuring Row Actions"},{"location":"guides/hyva-admin-grid-walkthrough/declaring-source-search-bindings.html","text":"Declaring source search bindings Sometimes we might want to show a data related to some other entity in a grid. For example, all orders or a customer. This can be achieved with a defaultSearchCriteriaBindings declaration. Take the the following example: < source > < repositoryListMethod > MagentoSalesApiOrderRepositoryInterface::getList </ repositoryListMethod > < defaultSearchCriteriaBindings > < field name = \"customer_id\" requestParam = \"id\" /> </ defaultSearchCriteriaBindings > </ source > This example shows only orders in the grid, where the order\u2019s customer_id attribute matches the value of the HTTP request parameter id . It is also possible to specify bindings against methods. However, specifying a binding for a field to match a request parameter is the most common case. If no default search criteria binding is needed, just omit the tag. The ways the bindings are declared are best explained by examples: The most simple example is: < field name = \"customer_id\" method = \"MagentoCustomerModelSession::getCustomerId\" /> The declaration will limit the grid data to records where the customer_id field matches the value of the expression $objectManager->get('MagentoCustomerModelSession')->getCustomerId() It is also possible to pass parameters to the method: < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" /> This example is the equivalent of using requestParam . It binds the entity_id field to the value of the expression $objectManager->get('MagentoFrameworkAppRequestInterface')->getParam('id'); Finally it\u2019s possible to go one level deeper and specify a binding against a property of the methods return value. < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> How the property is resolved depends on the returned value. If it is an array, the property will be used as an index of the array, e.g. $value['id'] . If the returned value is an object with a matching getter method, it will be called to produce the bound value. $objectManager->get('MagentoStoreModelStoreManagerInterface')->getStore()->getId(); If that method doesn\u2019t exist, the logic will also try to read the value in a number of other ways (from a public property, or using getData('id') , or using array access). If more complex or chained calls are necessary, they have to be wrapped in a custom class that then can be used in the XML.","title":"Declaring source search bindings"},{"location":"guides/hyva-admin-grid-walkthrough/declaring-source-search-bindings.html#declaring-source-search-bindings","text":"Sometimes we might want to show a data related to some other entity in a grid. For example, all orders or a customer. This can be achieved with a defaultSearchCriteriaBindings declaration. Take the the following example: < source > < repositoryListMethod > MagentoSalesApiOrderRepositoryInterface::getList </ repositoryListMethod > < defaultSearchCriteriaBindings > < field name = \"customer_id\" requestParam = \"id\" /> </ defaultSearchCriteriaBindings > </ source > This example shows only orders in the grid, where the order\u2019s customer_id attribute matches the value of the HTTP request parameter id . It is also possible to specify bindings against methods. However, specifying a binding for a field to match a request parameter is the most common case. If no default search criteria binding is needed, just omit the tag. The ways the bindings are declared are best explained by examples: The most simple example is: < field name = \"customer_id\" method = \"MagentoCustomerModelSession::getCustomerId\" /> The declaration will limit the grid data to records where the customer_id field matches the value of the expression $objectManager->get('MagentoCustomerModelSession')->getCustomerId() It is also possible to pass parameters to the method: < field name = \"entity_id\" method = \"MagentoFrameworkAppRequestInterface::getParam\" param = \"id\" /> This example is the equivalent of using requestParam . It binds the entity_id field to the value of the expression $objectManager->get('MagentoFrameworkAppRequestInterface')->getParam('id'); Finally it\u2019s possible to go one level deeper and specify a binding against a property of the methods return value. < field name = \"store_id\" method = \"MagentoStoreModelStoreManagerInterface::getStore\" property = \"id\" /> How the property is resolved depends on the returned value. If it is an array, the property will be used as an index of the array, e.g. $value['id'] . If the returned value is an object with a matching getter method, it will be called to produce the bound value. $objectManager->get('MagentoStoreModelStoreManagerInterface')->getStore()->getId(); If that method doesn\u2019t exist, the logic will also try to read the value in a number of other ways (from a public property, or using getData('id') , or using array access). If more complex or chained calls are necessary, they have to be wrapped in a custom class that then can be used in the XML.","title":"Declaring source search bindings"},{"location":"guides/hyva-admin-grid-walkthrough/declaring-the-grid-block.html","text":"Declaring the Grid Block The first step in creating a Hyv\u00e4 grid is to declare the grid block in layout XML and load alpine.js and tailwind. To load alpine.js and tailwind, use an update layout directive for the handle hyva_admin_grid : < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> </ page > The block usually is added to the content area container, and has to be a HyvaAdminBlockAdminhtmlHyvaGrid instance. Specify the grid name as the block name, or as a block argument grid_name . < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"demo-grid\" /> </ referenceContainer > This is what it looks like to specify the block name as an argument: < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"walkthrough-demo-grid\" > < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > demo-grid </ argument > </ arguments > </ block > </ referenceContainer > The name of the grid refers to the grid XML file name (without the .xml filename ending). For the above examples it would be [Module_Dir]/view/adminhtml/hyva-grid/demo-grid.xml .","title":"Declaring the Grid Block"},{"location":"guides/hyva-admin-grid-walkthrough/declaring-the-grid-block.html#declaring-the-grid-block","text":"The first step in creating a Hyv\u00e4 grid is to declare the grid block in layout XML and load alpine.js and tailwind. To load alpine.js and tailwind, use an update layout directive for the handle hyva_admin_grid : < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> </ page > The block usually is added to the content area container, and has to be a HyvaAdminBlockAdminhtmlHyvaGrid instance. Specify the grid name as the block name, or as a block argument grid_name . < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"demo-grid\" /> </ referenceContainer > This is what it looks like to specify the block name as an argument: < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"walkthrough-demo-grid\" > < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > demo-grid </ argument > </ arguments > </ block > </ referenceContainer > The name of the grid refers to the grid XML file name (without the .xml filename ending). For the above examples it would be [Module_Dir]/view/adminhtml/hyva-grid/demo-grid.xml .","title":"Declaring the Grid Block"},{"location":"guides/hyva-admin-grid-walkthrough/default-sort-order.html","text":"Default Sort Order The default sort order can be configured in the <navigation><sorting/></navigation> part of a grid XML file. < sorting > < defaultSortByColumn > created_at </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting > Users can change the sort order by clicking on the column titles. Clicking on a title multiple times reverses the sort order. For more detailed information about which columns are sortable and how sorting works, please refer to the Sorting Columns documentation in the design docs.","title":"Default Sort Order"},{"location":"guides/hyva-admin-grid-walkthrough/default-sort-order.html#default-sort-order","text":"The default sort order can be configured in the <navigation><sorting/></navigation> part of a grid XML file. < sorting > < defaultSortByColumn > created_at </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting > Users can change the sort order by clicking on the column titles. Clicking on a title multiple times reverses the sort order. For more detailed information about which columns are sortable and how sorting works, please refer to the Sorting Columns documentation in the design docs.","title":"Default Sort Order"},{"location":"guides/hyva-admin-grid-walkthrough/entity-config.html","text":"Entity Config This section of a Grid XML file simply supplies the name to render in the message when a grid contains no data. < entityConfig > < label > < singular > File </ singular > < plural > Files </ plural > </ label > </ entityConfig > This section is optional though, and if it is missing, the grid name is used to create a message. In future more information might be added here.","title":"Entity Config"},{"location":"guides/hyva-admin-grid-walkthrough/entity-config.html#entity-config","text":"This section of a Grid XML file simply supplies the name to render in the message when a grid contains no data. < entityConfig > < label > < singular > File </ singular > < plural > Files </ plural > </ label > </ entityConfig > This section is optional though, and if it is missing, the grid name is used to create a message. In future more information might be added here.","title":"Entity Config"},{"location":"guides/hyva-admin-grid-walkthrough/exports.html","text":"Exports Exports allow admin users to export the current selection of the grid. Filters and sort orders are applied when exporting a grid. Three export types are supported out of the box, and it also is possible to create custom export formats. Supported Export Formats: CSV XML XLSX Example: < navigation > < exports > < export type = \"csv\" label = \"Export as CSV\" /> < export type = \"xml\" label = \"Export as XML\" enabled = \"false\" /> < export type = \"xlsx\" label = \"Export as XLSX\" /> < export type = \"custom\" label = \"Export as my custom format\" class = \"MyModuleModelCustomGridExport\" fileName = \"example.foo\" sortOrder = \"1\" /> </ exports > </ navigation > For the known export types csv , xml and xlsx no class declaration is necessary. For custom types an export class needs to be specified. The custom export class has to extend from HyvaAdminModelGridExportTypeAbstractExportType .and implement the method public function createFileToDownload() . More information about custom export types can be found in the PHP API reference at Grid AbstractExportType . More information about the export XML configuration can be found in the XML API reference at grid > navigation > exports .","title":"Exports"},{"location":"guides/hyva-admin-grid-walkthrough/exports.html#exports","text":"Exports allow admin users to export the current selection of the grid. Filters and sort orders are applied when exporting a grid. Three export types are supported out of the box, and it also is possible to create custom export formats.","title":"Exports"},{"location":"guides/hyva-admin-grid-walkthrough/exports.html#supported-export-formats","text":"CSV XML XLSX","title":"Supported Export Formats:"},{"location":"guides/hyva-admin-grid-walkthrough/exports.html#example","text":"< navigation > < exports > < export type = \"csv\" label = \"Export as CSV\" /> < export type = \"xml\" label = \"Export as XML\" enabled = \"false\" /> < export type = \"xlsx\" label = \"Export as XLSX\" /> < export type = \"custom\" label = \"Export as my custom format\" class = \"MyModuleModelCustomGridExport\" fileName = \"example.foo\" sortOrder = \"1\" /> </ exports > </ navigation > For the known export types csv , xml and xlsx no class declaration is necessary. For custom types an export class needs to be specified. The custom export class has to extend from HyvaAdminModelGridExportTypeAbstractExportType .and implement the method public function createFileToDownload() . More information about custom export types can be found in the PHP API reference at Grid AbstractExportType . More information about the export XML configuration can be found in the XML API reference at grid > navigation > exports .","title":"Example:"},{"location":"guides/hyva-admin-grid-walkthrough/filtering.html","text":"Filtering By default columns are not filterable. This is the default because filtering is the most tricky thing to get right automatically. For simple columns types it works well, but as soon as some data is loaded in a special way it\u2019s no longer possible to apply filters automatically. Anyhow, filtering can be enabled for specific columns in the <navigation><filters/></navigation> section of a grid XML file. < navigation > < filters > < filter column = \"sku\" /> < filter column = \"activity\" /> < filter column = \"id\" /> </ filters > </ navigation > The order in which filters are configured has no effect. How a filter is rendered and how it is applied depends on the type of the column. So for example, a datetime column filter renders as a date-range filter. A column with string values will have a text input filter, and so on. It\u2019s also possible to create custom filter types if needed. Please refer to the filters documentation in the Grid XML API reference and the PHP Classes and Interfaces API reference for more information. Some information on custom filters can be found in the Filtering Extension Attribute Columns document in the deep docs.","title":"Filtering"},{"location":"guides/hyva-admin-grid-walkthrough/filtering.html#filtering","text":"By default columns are not filterable. This is the default because filtering is the most tricky thing to get right automatically. For simple columns types it works well, but as soon as some data is loaded in a special way it\u2019s no longer possible to apply filters automatically. Anyhow, filtering can be enabled for specific columns in the <navigation><filters/></navigation> section of a grid XML file. < navigation > < filters > < filter column = \"sku\" /> < filter column = \"activity\" /> < filter column = \"id\" /> </ filters > </ navigation > The order in which filters are configured has no effect. How a filter is rendered and how it is applied depends on the type of the column. So for example, a datetime column filter renders as a date-range filter. A column with string values will have a text input filter, and so on. It\u2019s also possible to create custom filter types if needed. Please refer to the filters documentation in the Grid XML API reference and the PHP Classes and Interfaces API reference for more information. Some information on custom filters can be found in the Filtering Extension Attribute Columns document in the deep docs.","title":"Filtering"},{"location":"guides/hyva-admin-grid-walkthrough/pagination.html","text":"Pagination Grids use a default page size, but that can be changed in the <navigation><pager/></navigation> section of a grid XML file. < navigation > < pager > < defaultPageSize > 5 </ defaultPageSize > < pageSizes > 2,5,10 </ pageSizes > </ pager > </ navigation > This is so simple I don\u2019t know what else to write about it.","title":"Pagination"},{"location":"guides/hyva-admin-grid-walkthrough/pagination.html#pagination","text":"Grids use a default page size, but that can be changed in the <navigation><pager/></navigation> section of a grid XML file. < navigation > < pager > < defaultPageSize > 5 </ defaultPageSize > < pageSizes > 2,5,10 </ pageSizes > </ pager > </ navigation > This is so simple I don\u2019t know what else to write about it.","title":"Pagination"},{"location":"guides/hyva-admin-grid-walkthrough/prerequisites-for-a-grid.html","text":"Prerequisites for a Grid To create a grid, we need a backend page. That means there needs to be A backend route configuration ( etc/adminhtml/routes.xml ). A backend action controller ( Controller/Adminhtml/Some/Page.php ). Some way to navigate to the page, so probably a etc/adminhtml/menu.xml entry. Maybe a etc/acl.xml entry for the controller and menu entry, too, even though Hyv\u00e4 grids don\u2019t use the ACL. A layout XML file for the page in view/adminhtml/layout/my_module_some_page.xml All of these are standard Magento things and not specific to Hyva_Admin.","title":"Prerequisites for a Grid"},{"location":"guides/hyva-admin-grid-walkthrough/prerequisites-for-a-grid.html#prerequisites-for-a-grid","text":"To create a grid, we need a backend page. That means there needs to be A backend route configuration ( etc/adminhtml/routes.xml ). A backend action controller ( Controller/Adminhtml/Some/Page.php ). Some way to navigate to the page, so probably a etc/adminhtml/menu.xml entry. Maybe a etc/acl.xml entry for the controller and menu entry, too, even though Hyv\u00e4 grids don\u2019t use the ACL. A layout XML file for the page in view/adminhtml/layout/my_module_some_page.xml All of these are standard Magento things and not specific to Hyva_Admin.","title":"Prerequisites for a Grid"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html","text":"Setting a Grid Data Source Every grid needs data to display. Hyva_Admin grids try to make it as simple as possible to take existing data and display it in a grid. Sources can be different types. Currently Hyva_Admin supports the following grid source types: Array Grid Source Type Repository Grid Source Type Collection Grid Source Type Query Grid Source Type The source type is configured in the grid XML file in a <source> element. The child element determines the type of provider Array Grid Source To set an array provider, use the <arrayProvider> element: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > Array providers have to implement the interface HyvaAdminApiHyvaGridArrayProviderInterface . More details on array providers can be found in the PHP Class API reference documentation. Array providers return the full data. Pagination, filtering and sorting is applied in later by Hyva_Admin. In future another array provider variation might be added that allows handling pagination directly, so it can work with efficiently with large data sets. Currently a collection of repository provider needs to be used for this. Repository Grid Source To set a repository source type, use the <repositoryListMethod> element: < source > < repositoryListMethod > MagentoCustomerApiCustomerRepositoryInterface::getList </ repositoryListMethod > </ source > The name of the method doesn\u2019t have to be getList . The important thing here is that the specified method takes a MagentoFrameworkApiSearchCriteriaInterface as an argument, and returns a MagentoFrameworkApiSearchResultsInterface like thing. In the core code convention is to name these methods getList , but you can use whatever name you want on custom repositories, as long as the input and output are the same. Collection Grid Source Next there is the collection source type. It is specified with the collection element: < source > < collection > MagentoCustomerModelResourceModelCustomerCollection </ collection > </ source > The collection has to be a DB collection, because that is how the sorting, paging and filtering is applied. That said, more basic collections are very rare, so most should \u201cjust work\u201d. Query Grid Source Finally there is the query source type. The query source type allows configuring a SQL select query in the grid XML. The result is displayed directly in the grid, without the need for any custom PHP classes. < source > < query > < select > < from table = \"sales_order\" /> < columns > < column name = \"status\" /> < column name = \"state\" /> < column name = \"created_at\" as = \"latest_order\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns > < groupBy > < column name = \"status\" /> < column name = \"state\" /> </ groupBy > </ select > </ query > </ source > At the time of writing query source providers support select expressions, join, group by and, union select. Pagination and sorting can be applied by configuring default search criteria bindings (see the next page in this walkthrough). Choosing the right source for a grid Often we can choose between a repository list method, a collection and maybe even another grid collection. For example, for Magento orders the choices are: MagentoSalesApiOrderRepositoryInterface::getList MagentoSalesModelResourceModelOrderCollection MagentoSalesModelResourceModelOrderGridCollection Which is best? As always the answer is, it depends. Most of the time it doesn\u2019t matter. Just use what you have at hand and see if it is good enough. Sometimes a repository returns entities with more columns that are not present on regular models. These might be extension attributes that are not loaded on the regular models. Other times grid collections contain aggregate fields that aren\u2019t available on regular collections or with entities loaded with a repository. This is the case for the order grid collection, where the index table contains a field for the full customer name. The regular order model only contains separate fields for the customer first and last name. A column containing the full name can make filtering for a specific customer name more convenient. Future provider types: More grid providers will be added and the existing ones improved, as the need arrises. If you implement a grid provider you find useful, please open a merge request!","title":"Setting a Grid Data Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#setting-a-grid-data-source","text":"Every grid needs data to display. Hyva_Admin grids try to make it as simple as possible to take existing data and display it in a grid. Sources can be different types. Currently Hyva_Admin supports the following grid source types: Array Grid Source Type Repository Grid Source Type Collection Grid Source Type Query Grid Source Type The source type is configured in the grid XML file in a <source> element. The child element determines the type of provider","title":"Setting a Grid Data Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#array-grid-source","text":"To set an array provider, use the <arrayProvider> element: < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > Array providers have to implement the interface HyvaAdminApiHyvaGridArrayProviderInterface . More details on array providers can be found in the PHP Class API reference documentation. Array providers return the full data. Pagination, filtering and sorting is applied in later by Hyva_Admin. In future another array provider variation might be added that allows handling pagination directly, so it can work with efficiently with large data sets. Currently a collection of repository provider needs to be used for this.","title":"Array Grid Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#repository-grid-source","text":"To set a repository source type, use the <repositoryListMethod> element: < source > < repositoryListMethod > MagentoCustomerApiCustomerRepositoryInterface::getList </ repositoryListMethod > </ source > The name of the method doesn\u2019t have to be getList . The important thing here is that the specified method takes a MagentoFrameworkApiSearchCriteriaInterface as an argument, and returns a MagentoFrameworkApiSearchResultsInterface like thing. In the core code convention is to name these methods getList , but you can use whatever name you want on custom repositories, as long as the input and output are the same.","title":"Repository Grid Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#collection-grid-source","text":"Next there is the collection source type. It is specified with the collection element: < source > < collection > MagentoCustomerModelResourceModelCustomerCollection </ collection > </ source > The collection has to be a DB collection, because that is how the sorting, paging and filtering is applied. That said, more basic collections are very rare, so most should \u201cjust work\u201d.","title":"Collection Grid Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#query-grid-source","text":"Finally there is the query source type. The query source type allows configuring a SQL select query in the grid XML. The result is displayed directly in the grid, without the need for any custom PHP classes. < source > < query > < select > < from table = \"sales_order\" /> < columns > < column name = \"status\" /> < column name = \"state\" /> < column name = \"created_at\" as = \"latest_order\" /> < expression as = \"count\" > COUNT(*) </ expression > </ columns > < groupBy > < column name = \"status\" /> < column name = \"state\" /> </ groupBy > </ select > </ query > </ source > At the time of writing query source providers support select expressions, join, group by and, union select. Pagination and sorting can be applied by configuring default search criteria bindings (see the next page in this walkthrough).","title":"Query Grid Source"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#choosing-the-right-source-for-a-grid","text":"Often we can choose between a repository list method, a collection and maybe even another grid collection. For example, for Magento orders the choices are: MagentoSalesApiOrderRepositoryInterface::getList MagentoSalesModelResourceModelOrderCollection MagentoSalesModelResourceModelOrderGridCollection Which is best? As always the answer is, it depends. Most of the time it doesn\u2019t matter. Just use what you have at hand and see if it is good enough. Sometimes a repository returns entities with more columns that are not present on regular models. These might be extension attributes that are not loaded on the regular models. Other times grid collections contain aggregate fields that aren\u2019t available on regular collections or with entities loaded with a repository. This is the case for the order grid collection, where the index table contains a field for the full customer name. The regular order model only contains separate fields for the customer first and last name. A column containing the full name can make filtering for a specific customer name more convenient.","title":"Choosing the right source for a grid"},{"location":"guides/hyva-admin-grid-walkthrough/setting-a-grid-data-source.html#future-provider-types","text":"More grid providers will be added and the existing ones improved, as the need arrises. If you implement a grid provider you find useful, please open a merge request!","title":"Future provider types:"},{"location":"guides/hyva-admin-grid-walkthrough/the-grid-xml-file.html","text":"The Grid XML file Grid XML files are located in the directory view/adminhtml/hyva-grid . A skeleton grid XML file looks like this: <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > </ grid > The grid XML file is named after the HyvaGrid block name or the grid_name layout XML argument on the block. For example, if the HyvaGrid block grid_name layout XML argument is my-first-grid , then the grid XML file name would be view/adminhtml/hyva-grid/my-first-grid.xml . < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > my-first-grid </ argument > </ arguments > The XML Schema declaration on the <grid> root element isn\u2019t needed, but it\u2019s a good idea to include it so IDEs like PHPStorm can offer autocompletion and validation. That makes writing the grid definition a breeze. < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > The XSD schema can be found in the Hyva_Admin module at etc/hyva-grid.xsd . Grid XML is merged on a per-grid bases like any other Magento XML file type. In this way it is possible to extend or customize grids declared in other modules.","title":"The Grid XML file"},{"location":"guides/hyva-admin-grid-walkthrough/the-grid-xml-file.html#the-grid-xml-file","text":"Grid XML files are located in the directory view/adminhtml/hyva-grid . A skeleton grid XML file looks like this: <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > </ grid > The grid XML file is named after the HyvaGrid block name or the grid_name layout XML argument on the block. For example, if the HyvaGrid block grid_name layout XML argument is my-first-grid , then the grid XML file name would be view/adminhtml/hyva-grid/my-first-grid.xml . < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > my-first-grid </ argument > </ arguments > The XML Schema declaration on the <grid> root element isn\u2019t needed, but it\u2019s a good idea to include it so IDEs like PHPStorm can offer autocompletion and validation. That makes writing the grid definition a breeze. < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > The XSD schema can be found in the Hyva_Admin module at etc/hyva-grid.xsd . Grid XML is merged on a per-grid bases like any other Magento XML file type. In this way it is possible to extend or customize grids declared in other modules.","title":"The Grid XML file"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html","text":"Using Grid Source Processors Grid source processors are rarely needed. They allow low level access to the grid data load process, in case the declarative nature of Hyv# admin grids is not sufficient. If you are only just beginning to use Hyv\u00e4 admin grids, feel free to skip this page and come back to it later if you are bumping against the boundaries of what can be done in configuration only. Sometimes the Hyva Admin Grid API is too limited for what you need to do. For example. applying a filter might require a non-standard process because it involves some external entity. In such cases it\u2019s possible to declare grid source processors. A grid can have any number of grid source processors. < source > < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" /> </ processors > </ source > Processors implement the interface HyvaAdminApiHyvaGridSourceProcessorInterface . (There is one extended processor interface for use with collections, the HyvaGridCollectionProcessorInterface . More on that further below). interface HyvaGridSourceProcessorInterface { /** * Provides the ability to mutate the grid $source before the grid data is loaded. * * @param mixed $source * @param SearchCriteriaInterface $searchCriteria * @param string $gridName */ public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void; /** * Provides the ability to change the raw grid result after it is loaded. * * @param mixed $rawResult * @param SearchCriteriaInterface $searchCriteria * @param string $gridName * @return mixed */ public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName); } If only one of the methods is needed, a processor can also extend from HyvaAdminModelGridSourceAbstractGridSourceProcessor and override only the needed method. The effect of processors could also be achieved using events or plugins, but processors are designed to require the least amount of boilerplate code. Grid Processor method arguments $source and $rawResult The beforeLoad and afterLoad , and they receive the grid source instance and the raw data. As you can see in the interface show above, the $source and $rawResult arguments are annotated to have the type mixed . This is because they depends on the grid source type that is being used. Repository Grid source $source : instance of the class on which the getList method is called $rawResult : MagentoFrameworkApiSearchResultsInterface instance Collection Grid source $source : Collection instance before the search criteria are applied $rawResult : Collection instance after the search criteria has been applied (it may already be loaded) Array Grid source $source : array provider instance $rawResult : array result after filtering but before pagination or sorting has been applied Query Grid source $source : MagentoFrameworkDBSelect instance after search criteria is applied $rawResult : Query result array with the structure ['data' => $rows, 'count' => $count] SearchCriteriaInterface $searchCriteria The SearchCriteriaInterface instance with all the filters, pagination and sorting values that should be applied for the current grid view. The search criteria is only provided for informational purposes - do not change any values on it, as that would cause the grid source to be queried multiple times. The reason is that the GridSource memoizes the grid data depending on the search criteria values. If the method is called again but the search criteria has changed, the query will be executed again. string $gridName The grid name is supplied for informational reasons, for example so it can be included in exception messages if needed. Example use cases: The use case for afterLoad don\u2019t really depend on the grid source type. afterLoad can always be used to change or enhance the source data. But what can be done in the beforeLoad method depends a lot on the grid source type. Use cases for the beforeLoad processor method include (but are not limited to): Repository Grid source Set properties on the repository to influence how the search criteria is applied, for example, the store ID. This will probably only be useful for custom repositories, not for repositories that are provided by the core. Collection Grid source Setting additional filters and flags on the collection. Array Grid source It really depends on what influence the array grid source provider class allows. Query Grid source Set bind values on the select instance, remove and alter any part of the query At the time of writing grid source processors are called in module load order - there is no way to apply a sort order. HyvaGridCollectionProcessorInterface This interface extends the regular HyvaGridSourceProcessorInterface with a method that is specific for collections: public function afterInitSelect(AbstractDbCollection $source, string $gridName): void; This afterInitSelect callback that is only applicable to collection grid sources. It is called every time the collection grid source is instantiated, before the search criteria is applied. The callback is intended to allow joining additional fields that will then be available as grid columns.","title":"Using Grid Source Processors"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#using-grid-source-processors","text":"Grid source processors are rarely needed. They allow low level access to the grid data load process, in case the declarative nature of Hyv# admin grids is not sufficient. If you are only just beginning to use Hyv\u00e4 admin grids, feel free to skip this page and come back to it later if you are bumping against the boundaries of what can be done in configuration only. Sometimes the Hyva Admin Grid API is too limited for what you need to do. For example. applying a filter might require a non-standard process because it involves some external entity. In such cases it\u2019s possible to declare grid source processors. A grid can have any number of grid source processors. < source > < processors > < processor class = \"HyvaAdminTestHyvaGridProcessorProductGridQueryProcessor\" /> </ processors > </ source > Processors implement the interface HyvaAdminApiHyvaGridSourceProcessorInterface . (There is one extended processor interface for use with collections, the HyvaGridCollectionProcessorInterface . More on that further below). interface HyvaGridSourceProcessorInterface { /** * Provides the ability to mutate the grid $source before the grid data is loaded. * * @param mixed $source * @param SearchCriteriaInterface $searchCriteria * @param string $gridName */ public function beforeLoad($source, SearchCriteriaInterface $searchCriteria, string $gridName): void; /** * Provides the ability to change the raw grid result after it is loaded. * * @param mixed $rawResult * @param SearchCriteriaInterface $searchCriteria * @param string $gridName * @return mixed */ public function afterLoad($rawResult, SearchCriteriaInterface $searchCriteria, string $gridName); } If only one of the methods is needed, a processor can also extend from HyvaAdminModelGridSourceAbstractGridSourceProcessor and override only the needed method. The effect of processors could also be achieved using events or plugins, but processors are designed to require the least amount of boilerplate code.","title":"Using Grid Source Processors"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#grid-processor-method-arguments","text":"","title":"Grid Processor method arguments"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#source-and-rawresult","text":"The beforeLoad and afterLoad , and they receive the grid source instance and the raw data. As you can see in the interface show above, the $source and $rawResult arguments are annotated to have the type mixed . This is because they depends on the grid source type that is being used. Repository Grid source $source : instance of the class on which the getList method is called $rawResult : MagentoFrameworkApiSearchResultsInterface instance Collection Grid source $source : Collection instance before the search criteria are applied $rawResult : Collection instance after the search criteria has been applied (it may already be loaded) Array Grid source $source : array provider instance $rawResult : array result after filtering but before pagination or sorting has been applied Query Grid source $source : MagentoFrameworkDBSelect instance after search criteria is applied $rawResult : Query result array with the structure ['data' => $rows, 'count' => $count]","title":"$source and $rawResult"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#searchcriteriainterface-searchcriteria","text":"The SearchCriteriaInterface instance with all the filters, pagination and sorting values that should be applied for the current grid view. The search criteria is only provided for informational purposes - do not change any values on it, as that would cause the grid source to be queried multiple times. The reason is that the GridSource memoizes the grid data depending on the search criteria values. If the method is called again but the search criteria has changed, the query will be executed again.","title":"SearchCriteriaInterface $searchCriteria"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#string-gridname","text":"The grid name is supplied for informational reasons, for example so it can be included in exception messages if needed.","title":"string $gridName"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#example-use-cases","text":"The use case for afterLoad don\u2019t really depend on the grid source type. afterLoad can always be used to change or enhance the source data. But what can be done in the beforeLoad method depends a lot on the grid source type. Use cases for the beforeLoad processor method include (but are not limited to): Repository Grid source Set properties on the repository to influence how the search criteria is applied, for example, the store ID. This will probably only be useful for custom repositories, not for repositories that are provided by the core. Collection Grid source Setting additional filters and flags on the collection. Array Grid source It really depends on what influence the array grid source provider class allows. Query Grid source Set bind values on the select instance, remove and alter any part of the query At the time of writing grid source processors are called in module load order - there is no way to apply a sort order.","title":"Example use cases:"},{"location":"guides/hyva-admin-grid-walkthrough/using-grid-source-processors.html#hyvagridcollectionprocessorinterface","text":"This interface extends the regular HyvaGridSourceProcessorInterface with a method that is specific for collections: public function afterInitSelect(AbstractDbCollection $source, string $gridName): void; This afterInitSelect callback that is only applicable to collection grid sources. It is called every time the collection grid source is instantiated, before the search criteria is applied. The callback is intended to allow joining additional fields that will then be available as grid columns.","title":"HyvaGridCollectionProcessorInterface"},{"location":"guides/quickstart/index.html","text":"Quickstart Introduction Once installed, grids can be added to any admin page by adding a bit of layout XML and a grid configuration file. The layout XML has to contain two things: A <update handle=\"hyva_admin_grid\"/> declaration to load alpine.js and tailwind. A HyvaAdminBlockAdminhtmlHyvaGrid block, with the name of the grid configuration as a the block name or a grid_name block argument or as the blocks name-in-layout. An example file view/adminhtml/layout/example.xml could look as follows: <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"example-grid\" /> </ referenceContainer > </ body > </ page > After that, a grid configuration has to be created in a directory [Your_Module]/view/adminhtml/hyva-grid , where the file names corresponds to the name that was passed to the grid block (with a .xml suffix added to the file name). For the example above it would be view/adminhtml/hyva-grid/example-grid.xml . When writing the grid configuration, any good IDE will allow for auto-completion and validation of the XML thanks to the XSD schema found in the Hyva_Admin module at etc/hyva-grid.xsd . The grid configuration will need contain a grid source specification. Currently that can be a repository list method, or a HyvaAdminApiHyvaGridArrayProviderInterface implementation. With no further configuration, all fields of the provided records are shown as grid columns. It's then possible to either exclude columns as needed, or, alternatively, specify an include-list for the columns to display. In many cases the default will be good enough and no further configuration beyond the grid source will be necessary. Grid row actions, mass actions, paging and filtering can also be configured as needed. If this quick start was a bit too terse, check out the walkthrough . Also, maybe have a look at the Examples documentation and the Grid XML reference for more information.","title":"Intro"},{"location":"guides/quickstart/index.html#quickstart-introduction","text":"Once installed, grids can be added to any admin page by adding a bit of layout XML and a grid configuration file. The layout XML has to contain two things: A <update handle=\"hyva_admin_grid\"/> declaration to load alpine.js and tailwind. A HyvaAdminBlockAdminhtmlHyvaGrid block, with the name of the grid configuration as a the block name or a grid_name block argument or as the blocks name-in-layout. An example file view/adminhtml/layout/example.xml could look as follows: <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"example-grid\" /> </ referenceContainer > </ body > </ page > After that, a grid configuration has to be created in a directory [Your_Module]/view/adminhtml/hyva-grid , where the file names corresponds to the name that was passed to the grid block (with a .xml suffix added to the file name). For the example above it would be view/adminhtml/hyva-grid/example-grid.xml . When writing the grid configuration, any good IDE will allow for auto-completion and validation of the XML thanks to the XSD schema found in the Hyva_Admin module at etc/hyva-grid.xsd . The grid configuration will need contain a grid source specification. Currently that can be a repository list method, or a HyvaAdminApiHyvaGridArrayProviderInterface implementation. With no further configuration, all fields of the provided records are shown as grid columns. It's then possible to either exclude columns as needed, or, alternatively, specify an include-list for the columns to display. In many cases the default will be good enough and no further configuration beyond the grid source will be necessary. Grid row actions, mass actions, paging and filtering can also be configured as needed. If this quick start was a bit too terse, check out the walkthrough . Also, maybe have a look at the Examples documentation and the Grid XML reference for more information.","title":"Quickstart Introduction"},{"location":"guides/quickstart/examples/adding-a-hyvagrid-block-in-layout-xml.html","text":"Adding a HyvaGrid Block in Layout XML The following is all the layout XML that is required to show a Hyva admin grid on an admin page. The <update> handle is needed to load alpine.js and tailwind. The HyvaGrid block with the grid_name arguement is needed to load the grid. The grid configuration then is read from view/adminhtml/hyva-grid/some-grid.xml . <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"some-grid\" /> </ referenceContainer > </ body > </ page > The grid name can also be specified with a block argument. The following example is equivalent with the one above: <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"demo-grid\" > < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > some-grid </ argument > </ arguments > </ block > </ referenceContainer > </ body > </ page >","title":"Adding a HyvaGrid Block in Layout XML"},{"location":"guides/quickstart/examples/adding-a-hyvagrid-block-in-layout-xml.html#adding-a-hyvagrid-block-in-layout-xml","text":"The following is all the layout XML that is required to show a Hyva admin grid on an admin page. The <update> handle is needed to load alpine.js and tailwind. The HyvaGrid block with the grid_name arguement is needed to load the grid. The grid configuration then is read from view/adminhtml/hyva-grid/some-grid.xml . <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"some-grid\" /> </ referenceContainer > </ body > </ page > The grid name can also be specified with a block argument. The following example is equivalent with the one above: <?xml version=\"1.0\"?> < page xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:framework:View/Layout/etc/page_configuration.xsd\" > < update handle = \"hyva_admin_grid\" /> < body > < referenceContainer name = \"content\" > < block class = \"HyvaAdminBlockAdminhtmlHyvaGrid\" name = \"demo-grid\" > < arguments > < argument name = \"grid_name\" xsi:type = \"string\" > some-grid </ argument > </ arguments > </ block > </ referenceContainer > </ body > </ page >","title":"Adding a HyvaGrid Block in Layout XML"},{"location":"guides/quickstart/examples/array-grid-data-provider.html","text":"Array Grid Data Provider This is an example for simple array grid data provider. The class needs to implement HyvaAdminApiHyvaGridArrayProviderInterface The getHyvaGridData method returns an array with all the records. Each record is a sub-array and will be rendered as a row in the grid. The grid columns are taken from the array keys of the first record in the returned array. <?php declare ( strict_types = 1 ); namespace HyvaAdminTestModel ; use HyvaAdminApiHyvaGridArrayProviderInterface ; use MagentoFrameworkAppFilesystemDirectoryList ; use MagentoFrameworkFilesystemIoFileFactory ; class LogFileListProvider implements HyvaGridArrayProviderInterface { private DirectoryList $directoryList ; private FileFactory $fileFactory ; public function __construct ( DirectoryList $directoryList , FileFactory $fileFactory ) { $this -> directoryList = $directoryList ; $this -> fileFactory = $fileFactory ; } public function getHyvaGridData () : array { $file = $this -> fileFactory -> create (); $file -> cd ( $this -> directoryList -> getPath ( DirectoryList :: LOG )); return $file -> ls (); } }","title":"Array Grid Data Provider"},{"location":"guides/quickstart/examples/array-grid-data-provider.html#array-grid-data-provider","text":"This is an example for simple array grid data provider. The class needs to implement HyvaAdminApiHyvaGridArrayProviderInterface The getHyvaGridData method returns an array with all the records. Each record is a sub-array and will be rendered as a row in the grid. The grid columns are taken from the array keys of the first record in the returned array. <?php declare ( strict_types = 1 ); namespace HyvaAdminTestModel ; use HyvaAdminApiHyvaGridArrayProviderInterface ; use MagentoFrameworkAppFilesystemDirectoryList ; use MagentoFrameworkFilesystemIoFileFactory ; class LogFileListProvider implements HyvaGridArrayProviderInterface { private DirectoryList $directoryList ; private FileFactory $fileFactory ; public function __construct ( DirectoryList $directoryList , FileFactory $fileFactory ) { $this -> directoryList = $directoryList ; $this -> fileFactory = $fileFactory ; } public function getHyvaGridData () : array { $file = $this -> fileFactory -> create (); $file -> cd ( $this -> directoryList -> getPath ( DirectoryList :: LOG )); return $file -> ls (); } }","title":"Array Grid Data Provider"},{"location":"guides/quickstart/examples/array-grid-provider-configuration.html","text":"Array Grid Provider Configuration This is how a grid with an array provider source can be configured. Technically not even an exclude column is required - but leaving only the source config in the example seemed like too little. <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > < columns > < exclude > < column name = \"leaf\" /> </ exclude > </ columns > </ grid >","title":"Array Grid Provider Configuration"},{"location":"guides/quickstart/examples/array-grid-provider-configuration.html#array-grid-provider-configuration","text":"This is how a grid with an array provider source can be configured. Technically not even an exclude column is required - but leaving only the source config in the example seemed like too little. <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < arrayProvider > HyvaAdminTestModelLogFileListProvider </ arrayProvider > </ source > < columns > < exclude > < column name = \"leaf\" /> </ exclude > </ columns > </ grid >","title":"Array Grid Provider Configuration"},{"location":"guides/quickstart/examples/repository-getlist-grid-data-provider.html","text":"Repository::getList Grid Data Provider This is an example for a grid configuration that uses the product repository as a data source. Repositories are the most common type of grid data providers, since they often already exist in the core or custom modules. The configuration can be as simple as the previous minimalist array provider example, but the example below showcases more grid configuration possibilities. <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"activity\" /> < column name = \"name\" /> < column name = \"image\" type = \"magento_product_image\" renderAsUnsecureHtml = \"true\" label = \"Main Image\" template = \"Hyva_AdminTest::image.phtml\" /> < column name = \"media_gallery\" renderAsUnsecureHtml = \"true\" /> < column name = \"price\" type = \"price\" /> < column name = \"short_description\" initiallyHidden = \"true\" /> </ include > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > < massActions idColumn = \"id\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" /> </ massActions > < navigation > < pager > < defaultPageSize > 5 </ defaultPageSize > < pageSizes > 2,5,10 </ pageSizes > </ pager > < sorting > < defaultSortByColumn > sku </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting > < filters > < filter column = \"sku\" /> < filter column = \"category_ids\" /> < filter column = \"id\" /> < filter column = \"color\" > < option label = \"reddish\" > < value > 16 </ value > < value > 17 </ value > < value > 18 </ value > </ option > < option label = \"blueish\" > < value > 12 </ value > </ option > < option label = \"rose\" > < value > 100 </ value > </ option > </ filter > </ filters > </ navigation > </ grid >","title":"Repository::getList Grid Data Provider"},{"location":"guides/quickstart/examples/repository-getlist-grid-data-provider.html#repositorygetlist-grid-data-provider","text":"This is an example for a grid configuration that uses the product repository as a data source. Repositories are the most common type of grid data providers, since they often already exist in the core or custom modules. The configuration can be as simple as the previous minimalist array provider example, but the example below showcases more grid configuration possibilities. <?xml version=\"1.0\"?> < grid xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation = \"urn:magento:module:Hyva_Admin:etc/hyva-grid.xsd\" > < source > < repositoryListMethod > MagentoCatalogApiProductRepositoryInterface::getList </ repositoryListMethod > </ source > < columns > < include > < column name = \"id\" /> < column name = \"sku\" /> < column name = \"activity\" /> < column name = \"name\" /> < column name = \"image\" type = \"magento_product_image\" renderAsUnsecureHtml = \"true\" label = \"Main Image\" template = \"Hyva_AdminTest::image.phtml\" /> < column name = \"media_gallery\" renderAsUnsecureHtml = \"true\" /> < column name = \"price\" type = \"price\" /> < column name = \"short_description\" initiallyHidden = \"true\" /> </ include > < exclude > < column name = \"category_gear\" /> </ exclude > </ columns > < actions idColumn = \"id\" > < action id = \"edit\" label = \"Edit\" url = \"*/*/edit\" /> < action id = \"delete\" label = \"Delete\" url = \"*/*/delete\" /> </ actions > < massActions idColumn = \"id\" > < action id = \"reindex\" label = \"Reindex\" url = \"*/massAction/reindex\" /> < action id = \"delete\" label = \"Delete\" url = \"*/massAction/delete\" requireConfirmation = \"true\" /> </ massActions > < navigation > < pager > < defaultPageSize > 5 </ defaultPageSize > < pageSizes > 2,5,10 </ pageSizes > </ pager > < sorting > < defaultSortByColumn > sku </ defaultSortByColumn > < defaultSortDirection > desc </ defaultSortDirection > </ sorting > < filters > < filter column = \"sku\" /> < filter column = \"category_ids\" /> < filter column = \"id\" /> < filter column = \"color\" > < option label = \"reddish\" > < value > 16 </ value > < value > 17 </ value > < value > 18 </ value > </ option > < option label = \"blueish\" > < value > 12 </ value > </ option > < option label = \"rose\" > < value > 100 </ value > </ option > </ filter > </ filters > </ navigation > </ grid >","title":"Repository::getList Grid Data Provider"}]}